:mod:`dbase32` API
==================

.. py:module:: dbase32
    :synopsis: base32-encoding with a sorted-order alphabet (for databases)


The core :mod:`dbase32` API consists of just six functions:

    * For encoding and decoding, there is :func:`db32enc()` and :func:`db32dec()`

    * For validation, there is :func:`isdb32()` and :func:`check_db32()`

    * :func:`random_id()` generates Dbase32 encoded random IDs

    * :func:`time_id()` generates random IDs that will sort by timestamp



Tutorial
--------

Encode a ``bytes`` instance with :func:`db32enc()`:

>>> from dbase32 import db32enc
>>> db32enc(b'binary foo')
'FCNPVRELI7J9FUUI'

Decode the resulting ``str`` instance with :func:`db32dec()`:

>>> from dbase32 import db32dec
>>> db32dec('FCNPVRELI7J9FUUI')
b'binary foo'

:func:`db32dec()` can also directly decode UTF-8 encoded ``bytes``:

>>> db32dec(b'FCNPVRELI7J9FUUI')
b'binary foo'

Use :func:`isdb32()` to test whether you have a valid Dbase32 encoded ID.  It
will return ``True`` if the ID is valid:

>>> from dbase32 import isdb32
>>> isdb32('FCNPVRELI7J9FUUI')
True

And will return ``False`` if the ID contains invalid characters:

>>> isdb32('FCNPVRELI7J9FUUZ')
False

Or will also return ``False`` if the ID is the wrong length:

>>> isdb32('FCNPVRELI7J9FUU')
False

You can likewise use :func:`check_db32()` to validate an ID.  It will return
``None`` if the ID is valid:

>>> from dbase32 import check_db32
>>> check_db32('FCNPVRELI7J9FUUI')

And will raise a ``ValueError`` if the ID contains invalid characters:

>>> check_db32('FCNPVRELI7J9FUUZ')  # doctest: -IGNORE_EXCEPTION_DETAIL
Traceback (most recent call last):
  ...
ValueError: invalid Dbase32: 'FCNPVRELI7J9FUUZ'

Or will also raise a ``ValueError`` if the ID is the wrong length:

>>> check_db32('FCNPVRELI7J9FUU')  # doctest: -IGNORE_EXCEPTION_DETAIL
Traceback (most recent call last):
  ...
ValueError: len(text) is 15, need len(text) % 8 == 0

When you don't need the decoded ID, it's faster to validate with
:func:`isdb32()` or :func:`check_db32()` than to validate with :func:`db32dec()`
and throw away the needlessly decoded value.

Use :func:`random_id()` to generate a Dbase32 encoded random ID.  By default it
returns a 120-bit (15-byte) ID, which will be 24 characters in length when
Dbase32 encoded:

>>> from dbase32 import random_id
>>> random_id()  # doctest: +SKIP
'UGT6U75VTJL8IRBBPRFONKOQ'

The *numbytes* keyword argument defaults to ``15``, but you can override this
to get an ID of a different length.  For example, you might want to create a
well-formed 240-bit (30-byte) `Dmedia`_ file ID for unit testing, which will be
48 characters in length when Dbase32 encoded:

>>> random_id(30)  # doctest: +SKIP
'AU8HC68B9IC6AY6B3NHWOGCI9VK4MTOUSFLWRD7TLQBC56MN'

:func:`random_id()` gets its random data from ``os.urandom()``.  This:

>>> _id = random_id(15)

Is equivalent to this:

>>> import os
>>> _id = db32enc(os.urandom(15))

Although note that the C implementation of :func:`random_id()` is faster than
the above because it does everything internally with no back-and-forth between
Python and C.

Lastly, use :func:`time_id()` to generate random IDs that will sort according to
their Unix timestamp with a one second granularity.

Similar to :func:`random_id()`, :func:`time_id()` returns a 120-bit (15-byte)
ID, which will be 24 characters in length when Dbase32 encoded.  The difference
is the first 4 bytes contain the Unix timestamp (32-bit unsigned big endian),
and the remaining 11 bytes are from ``os.urandom()``.

If you don't provide the *timestamp* argument, it will be automatically
generated by calling ``time.time()``:

>>> time_id()  # doctest: +SKIP
'DBFL77QDNXTGB7GB3JB9YCCK'

Or you can provide your own timestamp, for example to use a timestamp already
generated for another purpose:

>>> time_id(1234567890)  # doctest: +SKIP
'C9E38NQ89VDDM5DAI8NGWGN5'



Well-formed IDs
---------------

Dbase32 is not designed to encode arbitrary data.  Instead, it's designed only
to encode well-formed IDs like those used in `Dmedia`_ and `Novacut`_.

Unlike standard `RFC-3548 Base32`_ encoding, Dbase32 does *not* support
padding.  The binary data must always be a multiple of 40 bits (5 bytes) in
length.

Well-formed *data* to be encoded must meet the following condition::

    5 <= len(data) <= 60 and len(data) % 5 == 0

If this condition isn't met, :func:`db32enc()` will raise a ``ValueError``.

In addition to only containing letters in :data:`DB32ALPHABET`, well-formed
*text* to be decoded must meet the following condition::

    8 <= len(text) <= 96 and len(text) % 8 == 0

If this condition isn't met, both :func:`db32dec()` and :func:`check_db32()`
will raise a ``ValueError``.  Likewise, if this condition isn't met,
:func:`isdb32()` will return ``False``.



Functions
---------

.. function:: db32enc(data)

    Encode *data* as Dbase32 text.

    A ``str`` instance is returned:

    >>> db32enc(b'Bytes')
    'BCVQBSEM'

    *data* must be a ``bytes`` instance that meets the following condition::

        5 <= len(data) <= 60 and len(data) % 5 == 0

    If the above condition is not met, a ``ValueError`` is raised.


.. function:: db32dec(text)

    Decode Dbase32 *text*.

    A ``bytes`` instance is returned:

    >>> db32dec('BCVQBSEM')
    b'Bytes'

    *text* must be a ``str`` or ``bytes`` instance that meets the following
    condition::

        8 <= len(text) <= 96 and len(text) % 8 == 0

    If the above condition is not met, or if *text* contains any letters not
    in :data:`DB32ALPHABET`, a ``ValueError`` is raised.


.. function:: isdb32(text)

    Return ``True`` if *text* contains a valid Dbase32 encoded ID.

    >>> isdb32('39AYA9AY')
    True
    >>> isdb32('27AZ27AZ')
    False

    This function will only return ``True`` if *text* contains only letters
    in :data:`DB32ALPHABET`, and if *text* meets following condition::

        8 <= len(text) <= 96 and len(text) % 8 == 0

    Otherwise, ``False`` is returned.


.. function:: check_db32(text)

    Raise a ``ValueError`` if *text* is not a valid Dbase32 encoded ID.

    This function will raise a ``ValueError`` if *text* contains any letters
    that are not in :data:`DB32ALPHABET`.  For example:

    >>> check_db32('39AYA9AY')
    >>> check_db32('39AY27AZ')  # doctest: -IGNORE_EXCEPTION_DETAIL
    Traceback (most recent call last):
      ...
    ValueError: invalid Dbase32: '39AY27AZ'

    This function will likewise raise a ``ValueError`` if *text* doesn't meet
    the following condition::

        8 <= len(text) <= 96 and len(text) % 8 == 0

    If *text* is a valid Dbase32 ID, this function returns ``None``.


.. function:: random_id(numbytes=15)

    Return a Dbase32 encoded random ID.

    By default, a 120-bit (15-byte) ID is returned, which will be 24
    characters in length when Dbase32 encoded:

    >>> random_id()  # doctest: +SKIP
    'XM4OINLIPO6VVF549TWYNK89'

    If provided, *numbytes* must be an ``int`` such that::

        5 <= numbytes <= 60 and numbytes % 5 == 0

    The random data is from ``os.urandom()``.


.. function:: time_id(timestamp=-1)

    Return a Dbase32 encoded random ID that will sort according to timestamp.

    These IDs will sort in ascending order according to the Unix timestamp, with
    a one second granularity.

    Similar to :func:`random_id()`, this function returns a 120-bit (15-byte)
    ID, which will be 24 characters in length when Dbase32 encoded.

    The difference is the first 4 bytes of this ID are the time since the Unix
    Epoch in seconds, truncated a 32-bit unsigned integer (which wont overflow
    till the year 2106).  The remaining 11 bytes are from ``os.urandom()``.

    This function is aimed at event logging and similar scenarios where it's
    handy for the IDs to sort chronologically.

    If you provide the optional *timestamp* kwarg, that timestamp will be used.
    Otherwise the timestamp is built by calling ``time.time()``.



.. _path-functions:

Path Functions
--------------

.. warning::

    These functions are an *experimental* part of the Dbase32 API!  They might
    still change in backward-incompatible ways, be renamed, or be removed entirely!

Dbase32 1.6 introduced two **experimental** functions that test whether some
untrusted input is a valid Dbase32 ID and, if valid, construct a file-system
path from it. (Or if this unstrusted input is not a valid Dbase32 ID, these
functions raise a ``ValueError``.)

These experimental functions are currently quite inflexible and might not be
broadly useful.  They're squarely aimed at the directory and file layout used
by the `Dmedia FileStore`_, where the first two characters of a valid Dbase32 ID
are used to construct a sub-directory name, and the remaining characters are
used to construct a filename within that sub-directory.

The :func:`db32_abspath()` function constructs an absolute path where the Dbase32
ID is used to append a sub-directory name plus a filename to a provided parent
directory name.  For example, you could build such an absolute path from a valid
Dbase32 ID like this:

>>> from dbase32 import check_db32
>>> parentdir = '/my/parent/directory'
>>> _id = 'FCNPVRELI7J9FUUI'
>>> check_db32(_id)
>>> '/'.join([parentdir, _id[0:2], _id[2:]])
'/my/parent/directory/FC/NPVRELI7J9FUUI'

Which is exactly what the :func:`db32_abspath()` function does:

>>> from dbase32 import db32_abspath
>>> db32_abspath(parentdir, _id)
'/my/parent/directory/FC/NPVRELI7J9FUUI'

On the other hand, the :func:`db32_relpath()` function constructs an
unqualified, relative path that, among other things, can be useful when opening
files relative to an open directory descriptor.  For example, you could build
such a relative path from a valid Dbase32 ID like this:

>>> check_db32(_id)
>>> '/'.join([_id[0:2], _id[2:]])
'FC/NPVRELI7J9FUUI'

Which is exactly what the :func:`db32_relpath()` function does:

>>> from dbase32 import db32_relpath
>>> db32_relpath(_id)
'FC/NPVRELI7J9FUUI'

The goal of these functions is to provide a simple, high-performance way of
constructing file-system paths from Dbase32 IDs, all while offering robust
protection against directory traversal attacks and similar security issues.

At present these fuctions are an **experimental** part of the Dbase32 API, so
bear in mind that they still might undergo backward-incompatible changes, be
renamed, or even be removed from the Dbase32 API altogether.

Also note that these functions are currently not portable, cannot be used to
construct file-systems paths under Windows.  They're currently hard-coded to use
``'/'`` as the separator rather than using ``os.sep``.  The reason for this is
that there's an interesting use-case for always using ``'/'`` as the separator
regardless of the value of ``os.sep`` on your particular platform: constructing
URLs.  Till the details are sorted out in terms of how best to do this in the
API, they've been hard-coded to use ``'/'``.


.. function:: db32_abspath(parentdir, text)

    Construct an absolute path with a 2-character directory name plus filename.

    .. warning::

        This function an *experimental* part of the Dbase32 API!  It might still
        change in backward-incompatible ways or be removed entirely!

    For example:

    >>> from dbase32 import db32_abspath
    >>> db32_abspath('/my/parent/directory', 'HELLOALL')
    '/my/parent/directory/HE/LLOALL'

    Similar to :func:`check_db32()`, a ``ValueError`` will be raised if *text*
    does not contain a valid Dbase32 ID:

    >>> db32_abspath('/my/parent/directory', '../very/naughty/')
    Traceback (most recent call last):
      ...
    ValueError: invalid Dbase32: '../very/naughty/'

    The *text* argument can be a ``str`` or ``bytes`` instance, but the return
    value is always a ``str`` instance:

    >>> db32_abspath('/my/parent/directory', b'BYTESFOO')
    '/my/parent/directory/BY/TESFOO'

    However, the *parentdir* argument must always be a ``str`` instance.

    Note that currently :func:`db32_abspath()` does no validation of the
    *parentdir* (although it may in the future).  Typically you'll construct
    many file-system paths from a single parent directory, so you likely want
    to initially validate the *parentdir* to ensure that::

        assert os.path.abspath(parentdir) == parentdir

    In particular, this function assumes that the *parentdir* does not end with
    a ``'/'`` (which the above assertion would enforce).

    .. versionadded:: 1.6


.. function:: db32_relpath(text)

    Construct a relative path with a 2-character directory name plus filename.

    .. warning::

        This function an *experimental* part of the Dbase32 API!  It might still
        change in backward-incompatible ways or be removed entirely!

    For example:

    >>> from dbase32 import db32_relpath
    >>> db32_relpath('HELLOALL')
    'HE/LLOALL'

    Similar to :func:`check_db32()`, a ``ValueError`` will be raised if *text*
    does not contain a valid Dbase32 ID:

    >>> db32_relpath('../very/naughty/')
    Traceback (most recent call last):
      ...
    ValueError: invalid Dbase32: '../very/naughty/'

    The *text* argument can be a ``str`` or ``bytes`` instance, but the return
    value is always a ``str`` instance:

    >>> db32_relpath(b'BYTESFOO')
    'BY/TESFOO'

    Among other things, such a relative path can be used to open files relative
    to an open directory descriptor.

    .. versionadded:: 1.6



Constants
---------

The :mod:`dbase32` module defines several handy constants:

.. data:: using_c_extension

    A flag indicating whether the Dbase32 `C implementation`_ is being used.

    >>> import dbase32
    >>> dbase32.using_c_extension  # doctest: +SKIP
    True

    This will be ``True`` when the ``dbase32._dbase32`` C extension is being
    used, or ``False`` when the ``dbase32._dbase32py`` pure-Python fallback is
    being used.

    For both security and performance reasons, only the `C implementation`_ is
    recommended for production use.  As such, 3rd party software might want to
    use this attribute in their unit tests and/or runtime initialization to
    verify that the Dbase32 C extension is in fact being used.

    Please see :doc:`security` for more details.

    .. versionadded:: 1.4


.. data:: DB32ALPHABET

    A ``str`` containing the Dbase32 alphabet.

    >>> import dbase32
    >>> dbase32.DB32ALPHABET
    '3456789ABCDEFGHIJKLMNOPQRSTUVWXY'

    Note that the Dbase32 alphabet (encoding table) is in ASCII/UTF-8 sorted
    order:

    >>> dbase32.DB32ALPHABET == ''.join(sorted(set(dbase32.DB32ALPHABET)))
    True


.. data:: MAX_BIN_LEN

    Max length of data (in bytes) accepted for encoding.

    >>> import dbase32
    >>> dbase32.MAX_BIN_LEN
    60
    >>> dbase32.MAX_BIN_LEN * 8  # 480 bits
    480

    This constraint is used by :func:`db32enc()`, :func:`random_id()`, and
    :func:`time_id()`.


.. data:: MAX_TXT_LEN

    Max length of text (in characters) accepted for decoding or validation.

    >>> import dbase32
    >>> dbase32.MAX_TXT_LEN
    96
    >>> dbase32.MAX_TXT_LEN * 5 // 8 == dbase32.MAX_BIN_LEN
    True

    This constraint is used by :func:`db32dec()`, :func:`isdb32()`, and
    :func:`check_db32()`.


.. data:: RANDOM_BITS

    Default size (in bits) of the *decoded* ID generated by :func:`random_id()`.

    >>> import dbase32
    >>> dbase32.RANDOM_BITS
    120


.. data:: RANDOM_BYTES

    Default size (in bytes) of the *decoded* ID generated by :func:`random_id()`.

    >>> import dbase32
    >>> dbase32.RANDOM_BYTES
    15
    >>> dbase32.RANDOM_BYTES * 8 == dbase32.RANDOM_BITS
    True


.. data:: RANDOM_B32LEN

    Default size (in characters) of the ID generated by :func:`random_id()`.

    >>> import dbase32
    >>> dbase32.RANDOM_B32LEN
    24
    >>> dbase32.RANDOM_B32LEN * 5 // 8 == dbase32.RANDOM_BYTES
    True



.. _`Dbase32`: https://launchpad.net/dbase32
.. _`RFC-3548 Base32`: https://tools.ietf.org/html/rfc4648
.. _`Novacut`: https://launchpad.net/novacut
.. _`Dmedia`: https://launchpad.net/dmedia
.. _`Dmedia FileStore`: https://launchpad.net/filestore

.. _`C implementation`: http://bazaar.launchpad.net/~dmedia/dbase32/trunk/view/head:/dbase32/_dbase32.c

