#!/usr/bin/env python
# Time-stamp: <2016-04-04 11:22:53 Yingxiang Li>

##----PACKAGE------##
import argparse, time, sys, os
from argparse import RawTextHelpFormatter
from pkg_resources import resource_filename

##----MAIN---------##
def main():
	Args_ = Fun_Args()

	Refer_D_ = Args_.reference
	Data_F_ = Args_.data
	Outpu_F_ = Args_.output

	NameRaw_ = Args_.name
#	Contr_ = Args_.control
	Name_ = Fun_BeforRun(Refer_D_, Data_F_, Outpu_F_, NameRaw_)

	if not Name_:
		fun_Decor('Please fix the problems above and re-try!', 100, ' ', 0, 0)
	else:
		Fun_Proce(Args_, Refer_D_, Data_F_, Outpu_F_, Name_)

##----CODA---------##
		fun_Decor('> END', 100, ' ', 1, 1)
		fun_Decor('', 100, '-', 0, 0)
		print '''\t|                                               __.                                                |
\t|                                ___.  ____.   |  |  __. __.__.   __.                              |
\t|                              _/ ___\ \__  \  |  | <   y  |\  \ /  /                              |
\t|                              \  c___  /  a \_|  l__\___  | >  x  <                               |
\t|                               \_____>(______/|____//_____|/__/ \__\\                              |
\t|''' + '~'*42 + 'www.calyx.biz' + '~'*43 + '\n\n'

##----FUNCTION-----##
#--common--
def fun_MakeDir(Path_):
	Path_ = Path_.strip().rstrip("\\")
	if not os.path.exists(Path_):
		os.makedirs(Path_)
	return Path_

def fun_Write(File_, File_D_):
	Out_ = open(File_D_, 'w')
	Out_.writelines(File_)
	Out_.close()

def fun_BashOrder(Log_F_, OrderName_, Order_):
	Bash_D_ = fun_MakeDir(Log_F_) + OrderName_ + '.sh'
	Bash_O_ = 'bash ' + Bash_D_ + ' > ' + Log_F_ + OrderName_ + '.log 2>&1'
	fun_Write(Order_, Bash_D_)
	os.system(Bash_O_)

def fun_Decor(Title_, Width_ = 100, DecorType_ = ' ', ShowTime_ = 1, ShowDate_ = 0):
	if ShowTime_ == 1:
		if ShowDate_ == 0:
			Decor_ = '\t|' + Title_ + DecorType_*(Width_ - 2 - len(Title_) - 11) + ' @ ' + time.strftime("%X", time.localtime()) + '|'
		else:
			Decor_ = '\t|' + Title_ + DecorType_*(Width_ - 2 - len(Title_) - 22) + ' @ ' + time.strftime("%Y-%m-%d %X", time.localtime()) + '|'
	else:
		Decor_ = '\t|' + Title_ + DecorType_*(Width_ - 2 - len(Title_)) + '|'
	print Decor_

def fun_ProceTime(FunctName_, Finis_ = 0, Width_ = 100, Inden_ = 16):
	FunctNameInden_ = ' '*(Inden_ - len(FunctName_.split(':')[0])) + FunctName_
	if Finis_ == 0:		
		fun_Decor(FunctNameInden_ + ' '*(Width_ - 23 - len(FunctNameInden_)) + '  -running', Width_)
	else:
		fun_Decor(FunctNameInden_ + ' '*(Width_ - 23 - len(FunctNameInden_)) + ' -finished', Width_)

def fun_ToAbsolDir(Dir_):
	DirSplit_ = [x_ for x_ in Dir_.split('/') if x_ != '']
	CurreWorki_D_ = os.getcwd()
	CurreWorkiSplit_D_ = [x_ for x_ in CurreWorki_D_.split('/') if x_ != '']
	if len(set(DirSplit_)&set(CurreWorkiSplit_D_)) == 0:
		DirAbsol_ = CurreWorki_D_ + '/' + Dir_
	else:
		DirAbsol_ = Dir_
	return DirAbsol_

def fun_FileSize(File_D_):
	import os
	FileSize_ = os.path.getsize(File_D_)
	Unit_ = ['B', 'KB', 'MB', 'GB', 'TB', 'PB']
	UnitOrder_ = 0
	while len(str(FileSize_)) >= 5:
		FileSizePrevi_ = FileSize_
		UnitOrderPrevi_ = UnitOrder_
		FileSize_ = round(FileSize_/1024.0, 1)
		UnitOrder_ += 1
	return str(FileSizePrevi_) + ' ' + Unit_[UnitOrderPrevi_]

def fun_ThousSign(Numbe_):
	return str(format(int(Numbe_), ','))

def fun_UppeInitiWord(Word_):
	UppeInitiWord_ = Word_[0].upper() + Word_[1:].lower()
	return UppeInitiWord_

#--special-
def Fun_Args():
	Tool = os.path.basename(sys.argv[0])
	Versi = '3.4'
	Author = 'Yingxiang Li'
	Email = 'xlccalyx@gmail.com'
	Date = 'Apr 02, 2016'
	UpdateDate = '040316,040416,040516,040916'
	Home = 'www.calyx.biz'
	FullName = 'CRISPR Sequence Indel Analysis'
	Aim = 'This program is for analysis of indel from CRISPR sequence.'

	Parse_ = argparse.ArgumentParser(description = '\tTool:   ' + Tool + 'v' + Versi + '\n\tDate:   ' + Date + '\n\tAuthor: Yingxiang Li (xlccalyx@gmail.com)\n\tHome:   ' + Home + '\n\tMust-install (NOT guaranteed on other versions):\n\t        bwa: 0.7.5a; fastqc: v0.11.2; samtools: 1.3; java: 1.7.0_95', prog = Tool, formatter_class = RawTextHelpFormatter)

	Parse_.add_argument('-V', '--version', action = 'version', version = '%(prog)s v' + Versi)

	Parse_.add_argument('-R', '--reference', help = "reference direction, fasta format. (eg: my_ref.fa)", required = True)
	Parse_.add_argument('-D', '--data', help = "test sample's sequenced fastq folder, ONLY fastq in. one file for single end, two files for paired end. (eg: my_data/)", required = True)
	Parse_.add_argument('-O', '--output', help = "output folder for all result and recording. if not exists, will be created. (eg: my_output/)", required = True)

	Parse_.add_argument('-N', '--name', help = "sample name, default is name of output folder. (eg: my_sample)", default = 'NoName')

	Parse_.add_argument('-P', '--pvalue', help = "minimal p value of indels, default: 0.05.", default = '0.05')
	Parse_.add_argument('-B', '--basequality', help = "minimal base quality, default: 30.", default = '30')
	Parse_.add_argument('-A', '--varfreq', help = "minimal indel frequency, default: 0.0001.", default = '0.0001')

	Parse_.add_argument('-F', '--fastqc', help = "run fastqc to process quality control. default: ON. -F will trun OFF.", action = "store_false", default = True)
	Parse_.add_argument('-I', '--index', help = "create bwa index for the reference, you can disable if it exists. default: ON. -X will turn OFF.", action = "store_false", default = True)

	Parse_.add_argument('-U', '--unlimited', help = "read depth is unlimited when checking indels, default: OFF.", action = "store_true")
	Parse_.add_argument('-VI', '--indel', help = "search for the indel, default: ON. -I will turn OFF.", action = "store_false", default = True)
	Parse_.add_argument('-VR', '--readcount', help = "collect read counts of sequence, default: OFF.", action = "store_true")
	Parse_.add_argument('-VC', '--consensus', help = "return consensus call, default: OFF.", action = "store_true")
	Parse_.add_argument('-VS', '--snp', help = "look for SNP, default: OFF.", action = "store_true")

	Args_ = Parse_.parse_args()

	print '\n\n\t' + ' '.join(sys.argv[:]) + '\n'
	fun_Decor('', 100, '-', 0, 0)
	fun_Decor('Tool:   ' + Tool + ' v' + Versi, 100, ' ', 0, 0)
	fun_Decor('Author: ' + Author + ' (' + Email + ')', 100, ' ', 0, 0)
	fun_Decor('', 100, '-', 0, 0)
	fun_Decor('> BEGIN', 100, ' ', 1, 1)

	return Args_

#--Process00
def Fun_Proce(Args_, Refer_D_, Data_F_, Outpu_F_, Name_):

	PValue_ = Args_.pvalue
	BaseQuali_ = Args_.basequality
	VarFreq_ = Args_.varfreq

	FastQC_ = Args_.fastqc
	Index_ = Args_.index

	Unlim_ = Args_.unlimited
	Indel_ = Args_.indel
	ReadCount_ = Args_.readcount
	Conse_ = Args_.consensus
	Snp_ = Args_.snp

	if os.path.exists(os.path.normpath(Outpu_F_) + '/' + Name_ + '/'):
		fun_Decor('WARNING! Output folder exists.', 100, ' ', 1, 0)
	Outpu_F_ = fun_MakeDir(os.path.normpath(Outpu_F_) + '/' + Name_ + '/') 
	Log_F_ = fun_MakeDir(Outpu_F_ + '/Log/')
	#--bwa: index--
	Fun_BwaIndex(Log_F_, Refer_D_, Index_)
	#--fastq files--
	Fastq1_D_ = Data_F_ + sorted(os.listdir(Data_F_))[0]
	Fastq2_D_ = '' if len(os.listdir(Data_F_)) <= 1 else Data_F_ + sorted(os.listdir(Data_F_))[1]
	#--fastqc: quality control--
	Fun_FastQC(Outpu_F_, Log_F_, Fastq1_D_, Fastq2_D_, Name_, FastQC_)
	#--bwa: map--
	BwaMap_ = Fun_BwaMap(Outpu_F_, Log_F_, Fastq1_D_, Fastq2_D_, Name_, Refer_D_)
	if BwaMap_:
		#--samtools: sam to bam--
		SamToolsSamToBam_ = Fun_SamToolsSamToBam(Outpu_F_, Log_F_, Name_)

		if SamToolsSamToBam_:
			#--samtools: sort
			SamToolsSort_ = Fun_SamToolsSortIndex(Outpu_F_, Log_F_, Name_)
			#--samtools: index
			Fun_SamToolsIndex(Outpu_F_, Log_F_, Name_)

			if SamToolsSort_:
				#--samtools: multi pile up--
				SamToolsMultiPileUp_ = Fun_SamToolsMultiPileUp(Outpu_F_, Log_F_, Name_, Refer_D_, Unlim_)

				if SamToolsMultiPileUp_:
					#VarScan_ = os.path.join(os.path.abspath(os.path.dirname(__file__)), 'VarScan/VarScan.v2.3.9.jar')
					VarScan_ = resource_filename('CSIA', 'VarScan.v2.3.9.jar')

					#--varscan: indel
					Fun_VarScanIndel(Outpu_F_, Log_F_, Name_, VarScan_, BaseQuali_, VarFreq_, PValue_, Indel_)
					#--varscan: read count--
					Fun_VarScanReadCount(Outpu_F_, Log_F_, Name_, VarScan_, BaseQuali_, ReadCount_)
					#--varscan: consensus call--
					Fun_VarScanConseCall(Outpu_F_, Log_F_, Name_, VarScan_, BaseQuali_, PValue_, Conse_)
					#--varscan: snp--
					Fun_VarScanSnp(Outpu_F_, Log_F_, Name_, VarScan_, BaseQuali_, VarFreq_, PValue_, Snp_)

				else:
					fun_Decor('Please fix SAMtools mpileup and re-try!', 100, ' ', 0, 0)

			else:
				fun_Decor('Please fix SAMtools sort and re-try!', 100, ' ', 0, 0)

		else:
			fun_Decor('Please fix SAMtools sam to bam and re-try!', 100, ' ', 0, 0)

	else:
		fun_Decor('Please fix BWA map and re-try!', 100, ' ', 0, 0)

#---before run judgement--
def Fun_BeforRun(Refer_D_, Data_F_, Outpu_F_, Name_):
	NameFinal_ = False
	if not Refer_D_.endswith('.fa') and not Refer_D_.endswith('.fasta'):
		fun_Decor('ABORT! -R should be fa(sta) format!', 100, ' ', 1, 0)
		return NameFinal_		
	if not os.path.isdir(Data_F_):
		fun_Decor('ABORT! -D should be a folder!', 100, ' ', 1, 0)
		return NameFinal_
	else:
		FastqFile_ = [x_ for x_ in os.listdir(fun_ToAbsolDir(Data_F_)) if x_.endswith('fq') or x_.endswith('fastq')]
		if len(FastqFile_) > 2:
			fun_Decor('ABORT! -D No more than 2 fastq-ONLY files!', 100, ' ', 1, 0)
			return NameFinal_
		elif len(FastqFile_) == 0:
			fun_Decor('ABORT! -D Please set the fastq file folder!', 100, ' ', 1, 0)
			return NameFinal_
		elif len(FastqFile_) < len(os.listdir(fun_ToAbsolDir(Data_F_))):
			fun_Decor('ABORT! -D Please remove NOT-fastq files!', 100, ' ', 1, 0)
			return NameFinal_
		else:
			if Name_ == 'NoName':
				NameFinal_ = [x_ for x_ in Outpu_F_.split('/') if x_ != ''][-1]
				fun_Decor('WARNING! -N Folder name of output will be assigned as Name.', 100, ' ', 1, 0)
			else:
				NameFinal_ = Name_
			return NameFinal_

#---bwa: index--
def Fun_BwaIndex(Log_F_, Refer_D_, Index_):
	if Index_:
		fun_ProceTime('bwa: index')
		BwaIndex_O_ = 'bwa index -a bwtsw ' + Refer_D_
		ReferName_ = os.path.basename(os.path.splitext(Refer_D_)[0])
		fun_BashOrder(Log_F_, 'Bwa_Index.' + ReferName_, BwaIndex_O_)
		fun_ProceTime('bwa: index', 1)

#---FastQC: quality control--
def Fun_FastQC(Outpu_F_, Log_F_, Fastq1_D_, Fastq2_D_, Name_, FastQC_):
	if FastQC_:	
		fun_ProceTime('fastqc: quality control')
		FastQC_F_ = fun_MakeDir(Outpu_F_ + 'FastQC/')
		FastQC_O_ = 'fastqc -q --extract -o ' + FastQC_F_ + ' ' + Fastq1_D_ + ' ' + Fastq2_D_
		fun_BashOrder(Log_F_, 'FastQC_QualiyControl', FastQC_O_)
		fun_ProceTime('fastqc: quality control', 1)
		if len(os.listdir(FastQC_F_)) == 0:
			fun_Decor('WARNING! No fastqc result! Please check FastQC_QualiyControl.log!', 100, ' ', 1, 0)

#---bwa: map--
def Fun_BwaMap(Outpu_F_, Log_F_, Fastq1_D_, Fastq2_D_, Name_, Refer_D_):
	SinglOrPair_ = ['pair', 'single'][Fastq2_D_ == '']
	fun_ProceTime('bwa: map ' + SinglOrPair_)
	ReferName_ = os.path.basename(os.path.splitext(Refer_D_)[0])
	BwaMap_D_ = fun_MakeDir(Outpu_F_ + 'BWA/') + Name_ + '.sam'
	BwaMap_O_ = '''bwa mem -t 10 -R "@RG\\tID:''' + Name_ + '.BWA_map.' + SinglOrPair_ + '\\tLB:bwa\\tPL:NA\\tSM:' + Name_ + '\" ' + Refer_D_ + ' ' + Fastq1_D_ + ' ' + Fastq2_D_ + ' > '+ BwaMap_D_
	fun_BashOrder(Log_F_, 'Bwa_Map', BwaMap_O_)	
	fun_ProceTime('bwa: map', 1)
	if not os.path.isfile(BwaMap_D_):
		fun_Decor('ABORT! No bwa result! Please check Bwa_Map.log!', 100, ' ', 1, 0)
	else:
		return True
	
#---samtools: sam to bam--
def Fun_SamToolsSamToBam(Outpu_F_, Log_F_, Name_):
	fun_ProceTime('samtools: sam to bam')
	BwaMap_D_ = Outpu_F_ + 'BWA/' + Name_ + '.sam'
	Bam_D_ = fun_MakeDir(Outpu_F_ + 'SAMtools/') + Name_ + '.bam'
	SamToolsSamToBam_O_ = 'samtools view -bhS ' + BwaMap_D_ + ' -o ' + Bam_D_
	fun_BashOrder(Log_F_, 'SamTools_SamToBam', SamToolsSamToBam_O_)
	fun_ProceTime('samtools: sam to bam', 1)
	if not os.path.isfile(Bam_D_):
		fun_Decor('ABORT! No bam result! Please check SamTools_SamToBam.log!', 100, ' ', 1, 0)
	else:
		return True	

#---samtools: sort & index--
def Fun_SamToolsSortIndex(Outpu_F_, Log_F_, Name_):
	fun_ProceTime('samtools: sort & index')
	Bam_D_ = Outpu_F_ + 'SAMtools/' + Name_ + '.bam'
	BamSort_D_ = Bam_D_.replace('.bam' + '.sort.bam')
	SamToolsSort_O_ = 'samtools sort ' + Bam_D_ + ' -o ' + BamSort_D_
	SamToolsIndex_O_ = 'samtools index ' + BamSort_D_
	fun_BashOrder(Log_F_, 'SamTools_Sort', SamToolsSort_O_)
	fun_BashOrder(Log_F_, 'SamTools_Index', SamToolsIndex_O_)	
	fun_ProceTime('samtools: sort & index', 1)
	if not os.path.isfile(BamSort_D_):
		fun_Decor('ABORT! No bam sort result! Please check SamTools_Sort.log!', 100, ' ', 1, 0)
	else:
		return True

#---samtools: flagstat--
def Fun_SamToolsFlagStat(Outpu_F_, Log_F_, Name_):
	fun_ProceTime('samtools: flagstat')
	BamSort_D_ = Outpu_F_ + 'SAMtools/' + Name_ + '.sort.bam'
	FlagStat_D_ = BamSort_D_.replace('.sort.bam', '.flagstat.txt')
	SamToolsFlagStat_O_ = 'samtools flagstat ' + BamSort_D_ + ' > ' + FlagStat_D_
	fun_BashOrder(Log_F_, 'SamTools_FlagStat', SamToolsFlagStat_O_)
	fun_ProceTime('samtools: flagstat', 1)

#---samtools: multi pile up--
def Fun_SamToolsMultiPileUp(Outpu_F_, Log_F_, Name_, Refer_D_, Unlim_):
	fun_ProceTime('samtools: mpileup' + ['', ' (unlimited: True)'][Unlim_])
	BamSort_D_ = Outpu_F_ + 'SAMtools/' + Name_ + '.sort.bam'
	MultiPileUp_D_ = BamSort_D_.replace('.sort.bam', '.mpu')
	SamToolsMultiPileUp_O_ = 'samtools mpileup' + ['', ' -d10000000'][Unlim_] + ' -f ' + Refer_D_ + ' ' + BamSort_D_ + ' > ' + MultiPileUp_D_
	fun_BashOrder(Log_F_, 'SamTools_MultiPileUp', SamToolsMultiPileUp_O_)
	fun_ProceTime('samtools: mpileup', 1)
	if not os.path.isfile(MultiPileUp_D_):
		fun_Decor('ABORT! No multiple pile up result! Please check SamTools_MultiPileUp.log!', 100, ' ', 1, 0)
	else:
		return True

#---varscan: indel--
def Fun_VarScanIndel(Outpu_F_, Log_F_, Name_, VarScan_, BaseQuali_, VarFreq_, PValue_, Indel_):
	if Indel_:
		fun_ProceTime('varscan: indel (base quality: ' + BaseQuali_ + ', var freq: ' + VarFreq_ + ', pvalue: '+ PValue_ + ')')
		MultiPileUp_D_ = Outpu_F_ + 'SAMtools/' + Name_ + '.mpu'
		Indel_D_ = fun_MakeDir(Outpu_F_ + 'VarScan/') + Name_ + '.indel.tab'
		VarScanIndel_O_ = 'java -jar ' + VarScan_ + ' pileup2indel ' + MultiPileUp_D_ + ' --min-avg-qual ' + BaseQuali_  + ' --min-var-freq ' + VarFreq_+ ' --p-value ' + PValue_ + ' > ' + Indel_D_
		fun_BashOrder(Log_F_, 'VarScan_Indel', VarScanIndel_O_)
		fun_ProceTime('varscan: indel', 1)
		if not os.path.isfile(Indel_D_):
			fun_Decor('WARNING! No varscan indel result! Please check VarScan_Indel.log!', 100, ' ', 1, 0)

#---varscan: read count--
def Fun_VarScanReadCount(Outpu_F_, Log_F_, Name_, VarScan_, BaseQuali_, ReadCount_):
	if ReadCount_:
		fun_ProceTime('varscan: read count (base quality: ' + BaseQuali_ + ')')
		MultiPileUp_D_ = Outpu_F_ + 'SAMtools/' + Name_ + '.mpu'
		ReadCount_D_ = fun_MakeDir(Outpu_F_ + 'VarScan/') + Name_ + '.read.tab'
		VarScanReadCount_O_ = 'java -jar ' + VarScan_ + ' readcounts ' + MultiPileUp_D_ +  ' --min-base-qual ' + BaseQuali_ + ' --output-file ' + ReadCount_D_
		fun_BashOrder(Log_F_, 'VarScan_ReadCount', VarScanReadCount_O_)
		fun_ProceTime('varscan: read count', 1)
		if not os.path.isfile(ReadCount_D_):
			fun_Decor('WARNING! No varscan read counts result! Please check VarScan_ReadCount.log!', 100, ' ', 1, 0)

#---varscan: consensus call--
def Fun_VarScanConseCall(Outpu_F_, Log_F_, Name_, VarScan_, BaseQuali_, PValue_, Conse_):
	if Conse_:
		fun_ProceTime('varscan: consensus call (base quality: ' + BaseQuali_ + ', p value: '+ PValue_ + ')')
		MultiPileUp_D_ = Outpu_F_ + 'SAMtools/' + Name_ + '.mpu'
		ConsenCall_D_ = fun_MakeDir(Outpu_F_ + 'VarScan/') + Name_ + '.consensus.tab'
		VarScanConsenCall_O_ = 'java -jar ' + VarScan_ + ' pileup2cns ' + MultiPileUp_D_ +  ' --min-avg-qual ' + BaseQuali_ + ' --p-value ' + PValue_ + ' > ' + ConsenCall_D_
		fun_BashOrder(Log_F_, 'VarScan_ConseCall', VarScanConsenCall_O_)
		fun_ProceTime('varscan: consensus call', 1)
		if not os.path.isfile(ConsenCall_D_):
			fun_Decor('WARNING! No varscan consensus call result! Please check VarScan_ConseCall.log!', 100, ' ', 1, 0)

#---varscan: snp--
def Fun_VarScanSnp(Outpu_F_, Log_F_, Name_, VarScan_, BaseQuali_, VarFreq_, PValue_, Snp_):
	if Snp_:
		fun_ProceTime('varscan: snp (base quality: ' + BaseQuali_ + ', var freq: ' + VarFreq_ + ', p value: '+ PValue_ + ')')
		MultiPileUp_D_ = Outpu_F_ + 'SAMtools/' + Name_ + '.mpu'
		Snp_D_ = fun_MakeDir(Outpu_F_ + 'VarScan/') + Name_ + '.snp.tab'
		VarScanSnp_O_ = 'java -jar ' + VarScan_ + ' pileup2snp ' + MultiPileUp_D_ +  ' --min-avg-qual ' + BaseQuali_  + ' --min-var-freq ' + VarFreq_+ ' --p-value ' + PValue_ + ' > ' + Snp_D_
		fun_BashOrder(Log_F_, 'VarScan_Snp', VarScanSnp_O_)
		fun_ProceTime('varscan: snp', 1)
		if not os.path.isfile(Snp_D_):
			fun_Decor('WARNING! No varscan snp result! Please check VarScan_Snp.log!', 100, ' ', 1, 0)

##----PROCESS------##
if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        sys.stderr.write("User interrupted me! ;-) Bye!\n")
        sys.exit(0)

##----TEST--------##
