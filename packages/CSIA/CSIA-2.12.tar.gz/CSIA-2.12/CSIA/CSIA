#!/usr/bin/env python
# Time-stamp: <2016-04-04 11:22:53 Yingxiang Li>

##----PACKAGE------##
import argparse, time, sys, os, commands
from argparse import RawTextHelpFormatter
from pkg_resources import resource_filename

##----MAIN---------##
def main():
	Tool = 'CSIA'
	Versi = '2.12'
	Author = 'Yingxiang Li'
	Email = 'xlccalyx@gmail.com'
	Date = 'Apr 02, 2016'
	UpdateDate = '040316,040416,040516'
	Home = 'www.calyx.biz'
	FullName = 'CRISPR Sequence Indel Analysis'
	Aim = 'This program is for analysis of indel of CRISPR sequence.'

	Parse_ = argparse.ArgumentParser(description = '\tTool:   ' + Tool + 'v' + Versi + '\n\tDate:   ' + Date + '\n\tAuthor: Yingxiang Li (xlccalyx@gmail.com)\n\tHome:   ' + Home + '\n\tMust-install (NOT guaranteed on other versions):\n\t        bwa: 0.7.5a; fastqc: v0.11.2; samtools: 1.3; java: 1.7.0_95', formatter_class = RawTextHelpFormatter)
	Parse_ = argparse.ArgumentParser(prog = Tool)

	Parse_.add_argument('-V', '--version', action = 'version', version = '%(prog)s v' + Versi)

	Parse_.add_argument('-R', '--reference', help = "reference direction, fasta format. (eg: my_ref.fa)", required = True)
	Parse_.add_argument('-D', '--data', help = "one sample's sequenced fastq folder, ONLY fastq in. one file for single end, two files for paired end. (eg: my_data/)", required = True)
	Parse_.add_argument('-O', '--output', help = "output folder for all result and recording. if not exists, will be created. (eg: my_output/)", required = True)

	Parse_.add_argument('-N', '--name', help = "sample name, default is name of output folder. (eg: my_sample)", default = 'NoName')
	Parse_.add_argument('-P', '--pvalue', help = "minimal p value of indels, default: 0.05.", default = '0.05')
	Parse_.add_argument('-B', '--basequality', help = "minimal base quality, default: 30.", default = '30')
	Parse_.add_argument('-A', '--varfreq', help = "minimal indel frequency, default: 0.0001.", default = '0.0001')

	Parse_.add_argument('-F', '--fastqc', help = "run fastqc to process quality control. default: ON. -F will trun OFF.", action = "store_false", default = True)
	Parse_.add_argument('-X', '--index', help = "create bwa index for the reference, you can disable if it exists. default: ON. -X will turn OFF.", action = "store_false", default = True)

	Parse_.add_argument('-U', '--unlimited', help = "read depth is unlimited when checking indels, default: OFF.", action = "store_true")
	Parse_.add_argument('-I', '--indel', help = "search for the indel, default: ON. -I will turn OFF.", action = "store_false", default = True)
	Parse_.add_argument('-E', '--readcount', help = "collect read counts of sequence, default: OFF.", action = "store_true")
	Parse_.add_argument('-C', '--consensus', help = "return consensus call, default: OFF.", action = "store_true")
	Parse_.add_argument('-S', '--snp', help = "look for SNP, default: OFF.", action = "store_true")

	Args_ = Parse_.parse_args()	

	Refer_D_ = Args_.reference
	Data_F_ = Args_.data
	Outpu_F_ = Args_.output

	NameRaw_ = Args_.name
	PValue_ = Args_.pvalue
	BaseQuali_ = Args_.basequality
	VarFreq_ = Args_.varfreq

	FastQC_ = Args_.fastqc
	Index_ = Args_.index

	Unlim_ = Args_.unlimited
	Indel_ = Args_.indel
	ReadCount_ = Args_.readcount
	Conse_ = Args_.consensus
	Snp_ = Args_.snp

	fun_Decor('', 100, '-', 0, 0)
	fun_Decor('Tool:   ' + Tool + ' v' + Versi, 100, ' ', 0, 0)
	fun_Decor('Author: ' + Author + ' (' + Email + ')', 100, ' ', 0, 0)
	fun_Decor('', 100, '-', 0, 0)
	fun_Decor('> BEGIN', 100, ' ', 1, 1)

	Name_ = Fun_BeforRun(Refer_D_, Data_F_, Outpu_F_, NameRaw_)

	if not Name_:
		fun_Decor('Please fix the problems above and re-try!', 100, ' ', 0, 0)

	else:
		if os.path.exists(os.path.normpath(Outpu_F_) + '/' + Name_ + '/'):
			fun_Decor('WARNING! Output folder exists.', 100, ' ', 1, 0)
		Outpu_F_ = fun_MakeDir(os.path.normpath(Outpu_F_) + '/' + Name_ + '/') 
		Log_F_ = fun_MakeDir(Outpu_F_ + '/Log/')
		#--bwa: index--
		Fun_BwaIndex(Log_F_, Refer_D_, Index_)
		#--fastq files--
		Fastq1_D_ = Data_F_ + sorted(os.listdir(Data_F_))[0]
		Fastq2_D_ = '' if len(os.listdir(Data_F_)) <= 1 else Data_F_ + sorted(os.listdir(Data_F_))[1]
		#--fastqc: quality control--
		Fun_FastQC(Outpu_F_, Log_F_, Fastq1_D_, Fastq2_D_, Name_, FastQC_)
		#--bwa: map--
		BwaMap_ = Fun_BwaMap(Outpu_F_, Log_F_, Fastq1_D_, Fastq2_D_, Name_, Refer_D_)
		if BwaMap_:
			#--samtools: sam to bam--
			SamToolsSamToBam_ = Fun_SamToolsSamToBam(Outpu_F_, Log_F_, Name_)

			if SamToolsSamToBam_:
				#--samtools: sort
				SamToolsSort_ = Fun_SamToolsSort(Outpu_F_, Log_F_, Name_)
				#--samtools: index
				Fun_SamToolsIndex(Outpu_F_, Log_F_, Name_)

				if SamToolsSort_:
					#--samtools: multi pile up--
					SamToolsMultiPileUp_ = Fun_SamToolsMultiPileUp(Outpu_F_, Log_F_, Name_, Refer_D_, Unlim_)

					if SamToolsMultiPileUp_:
						#VarScan_ = os.path.join(os.path.abspath(os.path.dirname(__file__)), 'VarScan/VarScan.v2.3.9.jar')
						VarScan_ = resource_filename('CSIA', 'VarScan.v2.3.9.jar')
						#--varscan: indel
						Fun_VarScanIndel(Outpu_F_, Log_F_, Name_, VarScan_, BaseQuali_, VarFreq_, PValue_, Indel_)
						#--varscan: read count--
						Fun_VarScanReadCount(Outpu_F_, Log_F_, Name_, VarScan_, BaseQuali_, ReadCount_)
						#--varscan: consensus call--
						Fun_VarScanConseCall(Outpu_F_, Log_F_, Name_, VarScan_, BaseQuali_, PValue_, Conse_)
						#--varscan: snp--
						Fun_VarScanSnp(Outpu_F_, Log_F_, Name_, VarScan_, BaseQuali_, VarFreq_, PValue_, Snp_)
						#--reuslt summary--
						Fun_ResulSumma(Args_, Outpu_F_, Log_F_, Fastq1_D_, Fastq2_D_, Name_)

					else:
						fun_Decor('Please fix SamTools mpileup and re-try!', 100, ' ', 0, 0)

				else:
					fun_Decor('Please fix SamTools sort and re-try!', 100, ' ', 0, 0)

			else:
				fun_Decor('Please fix SamTools sam to bam and re-try!', 100, ' ', 0, 0)

		else:
			fun_Decor('Please fix Bwa map and re-try!', 100, ' ', 0, 0)

##----CODA---------##
		fun_Decor('> END', 100, ' ', 1, 1)
		fun_Decor('', 100, '-', 0, 0)
		print '''\t|                                               __.                                                |
\t|                                ___.  ____.   |  |  __. __.__.   __.                              |
\t|                              _/ ___\ \__  \  |  | <   y  |\  \ /  /                              |
\t|                              \  c___  /  a \_|  l__\___  | >  x  <                               |
\t|                               \_____>(______/|____//_____|/__/ \__\\                              |
\t|''' + '~'*42 + 'www.calyx.biz' + '~'*43		

##----FUNCTION-----##
#--common--
def fun_MakeDir(Path_):
	Path_ = Path_.strip().rstrip("\\")
	if not os.path.exists(Path_):
		os.makedirs(Path_)
	return Path_

def fun_Write(File_, File_D_):
	Out_ = open(File_D_, 'w')
	Out_.writelines(File_)
	Out_.close()

def fun_BashOrder(Log_F_, OrderName_, Order_):
	Bash_D_ = fun_MakeDir(Log_F_) + OrderName_ + '.sh'
	Bash_O_ = 'bash ' + Bash_D_ + ' > ' + Log_F_ + OrderName_ + '.log 2>&1'
	fun_Write(Order_, Bash_D_)
	os.system(Bash_O_)

def fun_Decor(Title_, Width_ = 100, DecorType_ = ' ', ShowTime_ = 1, ShowDate_ = 0):
	if ShowTime_ == 1:
		if ShowDate_ == 0:
			Decor_ = '\t|' + Title_ + DecorType_*(Width_ - 2 - len(Title_) - 11) + ' @ ' + time.strftime("%X", time.localtime()) + '|'
		else:
			Decor_ = '\t|' + Title_ + DecorType_*(Width_ - 2 - len(Title_) - 22) + ' @ ' + time.strftime("%Y-%m-%d %X", time.localtime()) + '|'
	else:
		Decor_ = '\t|' + Title_ + DecorType_*(Width_ - 2 - len(Title_)) + '|'
	print Decor_

def fun_ProceTime(FunctName_, Finis_ = 0, Width_ = 100, Inden_ = 16):
	FunctNameInden_ = ' '*(Inden_ - len(FunctName_)) + FunctName_
	if Finis_ == 0:		
		fun_Decor(FunctNameInden_ + ' '*(Width_ - 23 - len(FunctNameInden_)) + '  -running', Width_)
	else:
		fun_Decor(FunctNameInden_ + ' '*(Width_ - 23 - len(FunctNameInden_)) + ' -finished', Width_)

def fun_ToAbsolDir(Dir_):
	DirSplit_ = [x_ for x_ in Dir_.split('/') if x_ != '']
	CurreWorki_D_ = os.getcwd()
	CurreWorkiSplit_D_ = [x_ for x_ in CurreWorki_D_.split('/') if x_ != '']
	if len(set(DirSplit_)&set(CurreWorkiSplit_D_)) == 0:
		DirAbsol_ = CurreWorki_D_ + '/' + Dir_
	else:
		DirAbsol_ = Dir_
	return DirAbsol_

def fun_FileSize(File_D_):
	import os
	FileSize_ = os.path.getsize(File_D_)
	Unit_ = ['B', 'KB', 'MB', 'GB', 'TB', 'PB']
	UnitOrder_ = 0
	while len(str(FileSize_)) >= 5:
		FileSizePrevi_ = FileSize_
		UnitOrderPrevi_ = UnitOrder_
		FileSize_ = round(FileSize_/1024.0, 1)
		UnitOrder_ += 1
	return str(FileSizePrevi_) + ' ' + Unit_[UnitOrderPrevi_]

#--special-
#---before run judgement--
def Fun_BeforRun(Refer_D_, Data_F_, Outpu_F_, Name_):
	NameFinal_ = False
	if not Refer_D_.endswith('.fa') and not Refer_D_.endswith('.fasta'):
		fun_Decor('ABORT! -R should be fa(sta) format!', 100, ' ', 1, 0)
		return NameFinal_		
	if not os.path.isdir(Data_F_):
		fun_Decor('ABORT! -D should be a folder!', 100, ' ', 1, 0)
		return NameFinal_
	else:
		FastqFile_ = [x_ for x_ in os.listdir(fun_ToAbsolDir(Data_F_)) if x_.endswith('fq') or x_.endswith('fastq')]
		if len(FastqFile_) > 2:
			fun_Decor('ABORT! -D No more than 2 fastq-ONLY files!', 100, ' ', 1, 0)
			return NameFinal_
		elif len(FastqFile_) == 0:
			fun_Decor('ABORT! -D Please set the fastq file folder!', 100, ' ', 1, 0)
			return NameFinal_
		elif len(FastqFile_) < len(os.listdir(fun_ToAbsolDir(Data_F_))):
			fun_Decor('ABORT! -D Please remove NOT-fastq files!', 100, ' ', 1, 0)
			return NameFinal_
		else:
			if Name_ == 'NoName':
				NameFinal_ = [x_ for x_ in Outpu_F_.split('/') if x_ != ''][-1]
				fun_Decor('WARNING! -N Folder name of output will be assigned as Name.', 100, ' ', 1, 0)
			else:
				NameFinal_ = Name_
			return NameFinal_

#---bwa: index--
def Fun_BwaIndex(Log_F_, Refer_D_, Index_):
	if Index_:
		fun_ProceTime('bwa: index')
		BwaIndex_O_ = 'bwa index -a bwtsw ' + Refer_D_
		ReferName_ = os.path.basename(os.path.splitext(Refer_D_)[0])
		fun_BashOrder(Log_F_, 'Bwa_Index.' + ReferName_, BwaIndex_O_)
		fun_ProceTime('bwa: index', 1)

#---FastQC: quality control--
def Fun_FastQC(Outpu_F_, Log_F_, Fastq1_D_, Fastq2_D_, Name_, FastQC_):
	if FastQC_:	
		fun_ProceTime('fastqc: quality control')
		FastQC_F_ = fun_MakeDir(Outpu_F_ + 'FastQC/')
		FastQC_O_ = 'fastqc -q --extract -o ' + FastQC_F_ + ' ' + Fastq1_D_ + ' ' + Fastq2_D_
		fun_BashOrder(Log_F_, 'FastQC_QualiyControl', FastQC_O_)
		fun_ProceTime('fastqc: quality control', 1)
		if len(os.listdir(FastQC_F_)) == 0:
			fun_Decor('WARNING! No fastqc result! Please check FastQC_QualiyControl.log!', 100, ' ', 1, 0)

#---bwa: map--
def Fun_BwaMap(Outpu_F_, Log_F_, Fastq1_D_, Fastq2_D_, Name_, Refer_D_):
	fun_ProceTime('bwa: map')
	ReferName_ = os.path.basename(os.path.splitext(Refer_D_)[0])
	SinglOrPair_ = ['Pa', 'Si'][Fastq2_D_ == '']
	BwaMap_D_ = fun_MakeDir(Outpu_F_ + 'Bwa/') + Name_ + '.sam'
	BwaMap_O_ = '''bwa mem -t 10 -R "@RG\\tID:''' + Name_ + '.Bwa_Map' + SinglOrPair_ + '\\tLB:bwa\\tPL:NA\\tSM:' + Name_ + '\" ' + Refer_D_ + ' ' + Fastq1_D_ + ' ' + Fastq2_D_ + ' > '+ BwaMap_D_
	fun_BashOrder(Log_F_, 'Bwa_Map', BwaMap_O_)	
	fun_ProceTime('bwa: map', 1)
	if not os.path.isfile(BwaMap_D_):
		fun_Decor('ABORT! No bwa result! Please check Bwa_Map.log!', 100, ' ', 1, 0)
	else:
		return True
	
#---samtools: sam to bam--
def Fun_SamToolsSamToBam(Outpu_F_, Log_F_, Name_):
	fun_ProceTime('samtools: sam to bam')
	BwaMap_D_ = Outpu_F_ + 'Bwa/' + Name_ + '.sam'
	Bam_D_ = fun_MakeDir(Outpu_F_ + 'SamTools/') + Name_ + '.bam'
	SamToolsSamToBam_O_ = 'samtools view -bhS ' + BwaMap_D_ + ' -o ' + Bam_D_
	fun_BashOrder(Log_F_, 'SamTools_SamToBam', SamToolsSamToBam_O_)
	fun_ProceTime('samtools: sam to bam', 1)
	if not os.path.isfile(Bam_D_):
		fun_Decor('ABORT! No bam result! Please check SamTools_SamToBam.log!', 100, ' ', 1, 0)
	else:
		return True	

#---samtools: sort--
def Fun_SamToolsSort(Outpu_F_, Log_F_, Name_):
	fun_ProceTime('samtools: sort')
	Bam_D_ = Outpu_F_ + 'SamTools/' + Name_ + '.bam'
	BamSort_D_ = Outpu_F_ + 'SamTools/' + Name_ + '.Sort.bam'
	SamToolsSort_O_ = 'samtools sort ' + Bam_D_ + ' -o ' + BamSort_D_
	fun_BashOrder(Log_F_, 'SamTools_Sort', SamToolsSort_O_)
	fun_ProceTime('samtools: sort', 1)
	if not os.path.isfile(BamSort_D_):
		fun_Decor('ABORT! No bam sort result! Please check SamTools_Sort.log!', 100, ' ', 1, 0)
	else:
		return True

#---samtools: index--
def Fun_SamToolsIndex(Outpu_F_, Log_F_, Name_):
	fun_ProceTime('samtools: index')
	BamSort_D_ = Outpu_F_ + 'SamTools/' + Name_ + '.Sort.bam'
	SamToolsIndex_O_ = 'samtools index ' + BamSort_D_
	fun_BashOrder(Log_F_, 'SamTools_Index', SamToolsIndex_O_)
	fun_ProceTime('samtools: index', 1)

#---samtools: multi pile up--
def Fun_SamToolsMultiPileUp(Outpu_F_, Log_F_, Name_, Refer_D_, Unlim_):
	fun_ProceTime('samtools: mpileup' + ['', ' (unlimited: True)'][Unlim_])
	BamSort_D_ = Outpu_F_ + 'SamTools/' + Name_ + '.Sort.bam'
	MultiPileUp_D_ = Outpu_F_ + 'SamTools/' + Name_ + '.mpu'
	SamToolsMultiPileUp_O_ = 'samtools mpileup' + ['', ' -d10000000'][Unlim_] + ' -f ' + Refer_D_ + ' ' + BamSort_D_ + ' > ' + MultiPileUp_D_
	fun_BashOrder(Log_F_, 'SamTools_MultiplePileUp', SamToolsMultiPileUp_O_)
	fun_ProceTime('samtools: mpileup', 1)
	if not os.path.isfile(MultiPileUp_D_):
		fun_Decor('ABORT! No multiple pile up result! Please check SamTools_MultiplePileUp.log!', 100, ' ', 1, 0)
	else:
		return True

#---varscan: indel--
def Fun_VarScanIndel(Outpu_F_, Log_F_, Name_, VarScan_, BaseQuali_, VarFreq_, PValue_, Indel_):
	if Indel_:
		fun_ProceTime('varscan: indel (basequality: ' + BaseQuali_ + ', varfreq: ' + VarFreq_ + ', pvalue: '+ PValue_ + ')')
		MultiPileUp_D_ = Outpu_F_ + 'SamTools/' + Name_ + '.mpu'
		VarScanIndel_D_ = fun_MakeDir(Outpu_F_ + 'VarScan/') + Name_ + '.indel.tab'
		VarScanIndel_O_ = 'java -jar ' + VarScan_ + ' pileup2indel ' + MultiPileUp_D_ + ' --min-avg-qual ' + BaseQuali_  + ' --min-var-freq ' + VarFreq_+ ' --p-value ' + PValue_ + ' > ' + VarScanIndel_D_
		fun_BashOrder(Log_F_, 'VarScan_Indel', VarScanIndel_O_)
		fun_ProceTime('varscan: indel', 1)
		if not os.path.isfile(VarScanIndel_D_):
			fun_Decor('WARNING! No varscan indel result! Please check VarScan_Indel.log!', 100, ' ', 1, 0)

#---varscan: read count--
def Fun_VarScanReadCount(Outpu_F_, Log_F_, Name_, VarScan_, BaseQuali_, ReadCount_):
	if ReadCount_:
		fun_ProceTime('varscan: read count (basequality: ' + BaseQuali_ + ')')
		MultiPileUp_D_ = Outpu_F_ + 'SamTools/' + Name_ + '.mpu'
		VarScanReadCount_D_ = Outpu_F_ + 'VarScan/' + Name_ + '.read.tab'
		VarScanReadCount_O_ = 'java -jar ' + VarScan_ + ' readcounts ' + MultiPileUp_D_ +  ' --min-avg-qual ' + BaseQuali_ + ' --output-file ' + VarScanReadCount_D_
		fun_BashOrder(Log_F_, 'VarScan_ReadCount', VarScanReadCount_O_)
		fun_ProceTime('varscan: read count', 1)
		if not os.path.isfile(VarScanReadCount_D_):
			fun_Decor('WARNING! No varscan read counts result! Please check VarScan_ReadCount.log!', 100, ' ', 1, 0)

#---varscan: consensus call--
def Fun_VarScanConseCall(Outpu_F_, Log_F_, Name_, VarScan_, BaseQuali_, PValue_, Conse_):
	if Conse_:
		fun_ProceTime('varscan: consensus call (basequality: ' + BaseQuali_ + ', pvalue: '+ PValue_ + ')')
		MultiPileUp_D_ = Outpu_F_ + 'SamTools/' + Name_ + '.mpu'
		VarScanConsenCall_D_ = Outpu_F_ + 'VarScan/' + Name_ + '.consensus.tab'
		VarScanConsenCall_O_ = 'java -jar ' + VarScan_ + ' pileup2cns ' + MultiPileUp_D_ +  ' --min-avg-qual ' + BaseQuali_ + ' --p-value ' + PValue_ + ' > ' + VarScanConsenCall_D_
		fun_BashOrder(Log_F_, 'VarScan_ConseCall', VarScanConsenCall_O_)
		fun_ProceTime('varscan: consensus call', 1)
		if not os.path.isfile(VarScanConsenCall_D_):
			fun_Decor('WARNING! No varscan consensus call result! Please check VarScan_ConseCall.log!', 100, ' ', 1, 0)

#---varscan: snp--
def Fun_VarScanSnp(Outpu_F_, Log_F_, Name_, VarScan_, BaseQuali_, VarFreq_, PValue_, Snp_):
	if Snp_:
		fun_ProceTime('varscan: snp (basequality: ' + BaseQuali_ + ', varfreq: ' + VarFreq_ + ', pvalue: '+ PValue_ + ')')
		MultiPileUp_D_ = Outpu_F_ + 'SamTools/' + Name_ + '.mpu'
		VarScanSnp_D_ = Outpu_F_ + 'VarScan/' + Name_ + '.snp.tab'
		VarScanSnp_O_ = 'java -jar ' + VarScan_ + ' pileup2snp ' + MultiPileUp_D_ +  ' --min-avg-qual ' + BaseQuali_  + ' --min-var-freq ' + VarFreq_+ ' --p-value ' + PValue_ + ' > ' + VarScanSnp_D_
		fun_BashOrder(Log_F_, 'VarScan_Snp', VarScanSnp_O_)
		fun_ProceTime('varscan: snp', 1)
		if not os.path.isfile(VarScanSnp_D_):
			fun_Decor('WARNING! No varscan snp result! Please check VarScan_Snp.log!', 100, ' ', 1, 0)

#---result summary---
def Fun_ResulSumma(Args_, Outpu_F_, Log_F_, Fastq1_D_, Fastq2_D_, Name_):
	ResulSumma_D_ = Log_F_ + Name_ + '.summary.txt'
	ResulSumma_ = []
	ResulSumma_.append('Command:\t' + ' '.join(sys.argv[:]) + '\n')
	ResulSumma_.append('Reference Dir:\t' + Args_.reference + '\n')
	ResulSumma_.append('Data Folder:\t' + Args_.data + '\n')
	ResulSumma_.append('Data Size:\tFastq1(' + os.path.basename(os.path.splitext(Fastq1_D_)[0]) + '): ' + fun_FileSize(Fastq1_D_) + ['', '; Fastq2(' + os.path.basename(os.path.splitext(Fastq2_D_)[0]) + '): ' + fun_FileSize(Fastq2_D_)][Fastq2_D_ != ''] + '\n') 
	ResulSumma_.append('Output Folder:\t' + Args_.output + '\n')
	ResulSumma_.append('Name:\t' + Name_ + '\n')
	ResulSumma_.append('FastQC:\t' + Outpu_F_ + 'FastQC/' + '\n')
	ResulSumma_.append('Bwa Map:\t' + Outpu_F_ + 'Bwa/' + Name_ + '.sam' + '\n')
	ResulSumma_.append('Bwa Map (bam):\t' + Outpu_F_ + 'Bwa/' + Name_ + '.bam' + '\n')
	ResulSumma_.append('SamTools mpileup parameters:\tUnlimited: ' + ['Fasle', 'True'][Args_.unlimited] + '\n')
	ResulSumma_.append('SamTools mpileup:\t' + Outpu_F_ + 'SamTools/' + Name_ + '.mpu' + '\n')
	ResulSumma_.append('VarScan indel parameters:\tP Value: ' + Args_.pvalue + '; Base Quality: ' + Args_.basequality + '; Variant Frequency: ' + Args_.varfreq + '\n')
	ResulSumma_.append('VarScan indel:\t' + Outpu_F_ + 'VarScan/' + Name_ + '.indel.tab' + '\n')
	if Args_.readcount:
		ResulSumma_.append('VarScan read counts:\t' + Outpu_F_ + 'VarScan/' + Name_ + '.read.tab' + '\n')
	if Args_.consensus:
		ResulSumma_.append('VarScan consensus calls:\t' + Outpu_F_ + 'VarScan/' + Name_ + '.consensus.tab' + '\n')
	if Args_.snp:
		ResulSumma_.append('VarScan SNP:\t' + Outpu_F_ + 'VarScan/' + Name_ + '.snp.tab' + '\n')
	fun_Write(ResulSumma_, ResulSumma_D_)

##----PROCESS------##
if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        sys.stderr.write("User interrupted me! ;-) Bye!\n")
        sys.exit(0)

##----TEST--------##
