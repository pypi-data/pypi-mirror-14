import hmac
import hashlib
import struct
import numbers
import os
from Crypto.Cipher import AES


class PyEncryption(object):
    # Ciphertext format: [____HMAC____][____IV____][____CIPHERTEXT____].

    # DO NOT CHANGE THESE CONSTANTS!
    #
    # We spent *weeks* testing this code, making sure it is as perfect and
    # correct as possible. Are you going to do the same after making your
    # changes? Probably not. Besides, any change to these constants will break
    # the runtime tests, which are extremely important for your security.
    # You're literally millions of times more likely to screw up your own
    # security by changing something here than you are to fall victim to an
    # 128-bit key brute-force attack. You're also breaking your own
    # compatibility with future updates to this library, so you'll be left
    # vulnerable if we ever find a security bug and release a fix.
    #
    # So, PLEASE, do not change these constants.

    KEY_BYTE_SIZE = 16
    HASH_FUNCTION = hashlib.sha256
    MAC_BYTE_SIZE = 32
    ENCRYPTION_INFO = 'DefusePHP|KeyForEncryption'
    AUTHENTICATION_INFO = 'DefusePHP|KeyForAuthentication'

    def __init__(self):
        self.testState = 0

    # Use this to generate a random encryption key.
    def createNewRandomKey(self):
        self.runtimeTest()
        return self.secureRandom(self.KEY_BYTE_SIZE)

    # Encrypts a message.
    # $plaintext is the message to encrypt.
    # $key is the encryption key, a value generated by CreateNewRandomKey().
    # You MUST catch exceptions thrown by this function. See docs above.
    def encrypt(self, plainText, key):
        self.runtimeTest()

        if len(key) != self.KEY_BYTE_SIZE:
            raise CannotPerformOperationException('Bad key.')

        # Generate a sub-key for encryption.
        encKey = self.HKDF(
            self.HASH_FUNCTION,
            key,
            self.KEY_BYTE_SIZE,
            self.ENCRYPTION_INFO
        )

        # Generate a random initialization vector.
        ivSize = AES.block_size
        if ivSize <= 0:
            raise CannotPerformOperationException()

        iv = self.secureRandom(ivSize)

        cipherText = iv + self.plainEncrypt(plainText, encKey, iv)

        # Generate a sub-key for authentication and apply the HMAC.
        authKey = self.HKDF(
            self.HASH_FUNCTION,
            key,
            self.KEY_BYTE_SIZE,
            self.AUTHENTICATION_INFO
        )
        h = hmac.new(
            authKey,
            cipherText,
            self.HASH_FUNCTION
        )
        auth = h.digest()
        return auth + cipherText

    def decrypt(self, cipherText, key):
        self.runtimeTest()

        # Extract the HMAC from the front of the ciphertext.
        if len(cipherText) <= self.MAC_BYTE_SIZE:
            raise InvalidCipherTextException

        hmacExtract = self.ourSubStr(
            cipherText,
            0,
            self.MAC_BYTE_SIZE
        )

        cipherText = self.ourSubStr(
            cipherText,
            self.MAC_BYTE_SIZE
        )

        # Regenerate the same authentication sub-key
        authKey = self.HKDF(
            self.HASH_FUNCTION,
            key,
            self.KEY_BYTE_SIZE,
            self.AUTHENTICATION_INFO
        )

        if self.verifyHMAC(hmacExtract, cipherText, authKey):
            # Regenerate the same encryption sub-key
            encKey = self.HKDF(
                self.HASH_FUNCTION,
                key,
                self.KEY_BYTE_SIZE,
                self.ENCRYPTION_INFO
            )

            # Extract the initialization vector from the ciphertext.
            ivSize = AES.block_size
            if ivSize <= 0:
                raise CannotPerformOperationException

            if len(cipherText) <= ivSize:
                raise InvalidCipherTextException

            iv = self.ourSubStr(cipherText, 0, ivSize)
            cipherText = self.ourSubStr(cipherText, ivSize)

            return self.plainDecrypt(cipherText, encKey, iv)

        else:
            # We throw an exception instead of returning FALSE because we want
            # a script that doesn't handle this condition to CRASH, instead
            # of thinking the ciphertext decrypted to the value FALSE.
            raise InvalidCipherTextException

    # Runs tests.
    # Raises CannotPerformOperationException or CryptoTestFailedException if
    # one of the tests fail. If any tests fails, your system is not capable of
    # performing encryption, so make sure you fail safe in that case.
    def runtimeTest(self):
        # 0: Tests haven't been run yet.
        # 1: Tests have passed.
        # 2: Tests are running right now.
        # 3: Tests have failed.
        if self.testState == 1 or self.testState == 2:
            return

        try:
            self.testState = 2
            self.AESTestVector()
            self.HMACTestVector()
            self.HKDFTestVector()

            self.testEncryptDecrypt()
            if len(self.createNewRandomKey()) != self.KEY_BYTE_SIZE:
                raise CryptoTestFailedException

            if self.ENCRYPTION_INFO == self.AUTHENTICATION_INFO:
                raise CryptoTestFailedException
        except CryptoTestFailedException as e:
            self.testState = 3
            raise

        # Change this to '0' make the tests always re-run (for benchmarking)
        self.testState = 1

    # Never call this method directly!
    def plainEncrypt(self, plainText, key, iv):
        cipher = AES.new(key, AES.MODE_CBC, iv)
        # Block padding
        paddingLength = 16 - (len(plainText) % 16)
        plainText += chr(paddingLength) * paddingLength

        return cipher.encrypt(plainText)

    # Never call this method directly!
    def plainDecrypt(self, cipherText, key, iv):
        cipher = AES.new(key, AES.MODE_CBC, iv)
        plainText = cipher.decrypt(cipherText)
        # Block padding
        paddingLength = ord(plainText[-1])
        return plainText[:-paddingLength]


    def secureRandom(self, octets):
        return os.urandom(octets)

    # Use HKDF to derive multiple keys from one.
    # http://tools.ietf.org/html/rfc5869
    def HKDF(self, hashFunction, ikm, length, info='', salt=None):
        # Find the correct digest length as quickly as we can.
        digestLength = self.MAC_BYTE_SIZE
        if (hashFunction != self.HASH_FUNCTION):
            h = hmac.new('', '', hashFunction)
            digestLength = len(h.digest())

        # Sanity-check the desired output length.
        if not isinstance(length, numbers.Number) or length < 0 or length > (255 * digestLength):
            raise CannotPerformOperationException

        # "if [salt] not provided, is set to a string of HashLen zeroes."
        if salt is None:
            salt = '\x00' * digestLength

        # HKDF-Extract:
        # PRK = HMAC-Hash(salt, IKM)
        # The salt is the HMAC key
        h = hmac.new(
            salt,
            ikm,
            hashFunction
        )
        prk = h.digest()

        # HKDF-Expand:

        # This check is useless, but it serves as reminder to the spec.
        if len(prk) < digestLength:
            raise CannotPerformOperationException

        # T(0) = ''
        t = ''
        lastBlock = ''
        blockIndex = 1
        while len(t) < length:
            # T(i) = HMAC-Hash(PRK, T(i-1) | info | 0x??)
            h = hmac.new(
                prk,
                lastBlock + info + chr(blockIndex),
                hashFunction
            )
            lastBlock = h.digest()
            # T = T(1) | T(2) | T(3) | ... | T(N)
            t += lastBlock
            blockIndex += 1

        # ORM = first L octets of T
        orm = self.ourSubStr(t, 0, length)
        if orm is False:
            raise CannotPerformOperationException

        return orm

    def verifyHMAC(self, correctHMAC, message, key):
        h = hmac.new(key, message, self.HASH_FUNCTION)
        messageHMAC = h.digest()

        # We can't just compare the strings with '==', since it would make
        # timing attacks possible. We could use the XOR-OR constant-time
        # comparison algorithm, but I'm not sure if that's good enough way up
        # here in an interpreted language. So we use the method of HMACing the
        # strings we want to compare with a random key, then comparing those.

        # NOTE: This leaks information when the strings are not the same
        # length, but they should always be the same length here. Enforce it:

        if (len(correctHMAC) != len(messageHMAC)):
            raise CannotPerformOperationException

        blind = self.createNewRandomKey()
        h = hmac.new(
            blind,
            messageHMAC,
            self.HASH_FUNCTION
        )
        messageCompare = h.hexdigest()
        h = hmac.new(
            blind,
            correctHMAC,
            self.HASH_FUNCTION
        )
        correctCompare = h.hexdigest()
        return (correctCompare == messageCompare)

    def testEncryptDecrypt(self):
        key = self.createNewRandomKey()
        data = 'EnCrYpT EvErYThInG\x00\x00'

        # Make sure encrypting then decrypting doesn't change the message.
        cipherText = self.encrypt(data, key)
        try:
            decrypted = self.decrypt(cipherText, key)
        except InvalidCipherTextException as e:
            # It's important to catch this and change it into a
            # CryptoTestFailedException, otherwise a test failure could trick
            # the user into thinking it's just an invalid ciphertext!
            raise CryptoTestFailedException

        if (decrypted != data):
            raise CryptoTestFailedException

        # Modifying the ciphertext: Appending a string.
        try:
            self.decrypt(cipherText + 'a', key)
            raise CryptoTestFailedException
        except InvalidCipherTextException as e:
            # expected
            pass

        # Modifying the ciphertext: Changing an IV byte.
        try:
            cipherText = chr((ord(cipherText[0]) + 1) % 256) + cipherText[1:]
            self.decrypt(cipherText, key)
            raise CryptoTextFailedException
        except InvalidCipherTextException as e:
            # expected
            pass

        # Decrypting with the wrong key.
        key = self.createNewRandomKey()
        data = 'abcdef'
        cipherText = self.encrypt(data, key)
        wrongKey = self.createNewRandomKey()
        try:
            self.decrypt(cipherText, wrongKey)
            raise CryptoTestFailedException
        except InvalidCipherTextException as e:
            # expected
            pass

        # Ciphertext too small (shorter than HMAC).
        key = self.createNewRandomKey()
        cipherText = 'A' * (self.MAC_BYTE_SIZE - 1)
        try:
            self.decrypt(cipherText, key)
            raise CryptoTestFailedException
        except InvalidCipherTextException as e:
            # expected
            pass

    def HKDFTestVector(self):
        # HKDF test vectors from RFC 5869

        # Test Case 1
        ikm = '\x0b' * 22
        salt = self.hexToBytes('000102030405060708090a0b0c')
        info = self.hexToBytes('f0f1f2f3f4f5f6f7f8f9')
        length = 42
        okm = self.hexToBytes(
            '3cb25f25faacd57a90434f64d0362f2a' +
            '2d2d0a90cf1a5a4c5db02d56ecc4c5bf' +
            '34007208d5b887185865'
        )
        computedOkm = self.HKDF(
            hashlib.sha256,
            ikm,
            length,
            info,
            salt
        )

        if (computedOkm != okm):
            raise CryptoTestFailedException

        # Test Case 7
        ikm = '\x0c' * 22
        length = 42
        okm = self.hexToBytes(
            '2c91117204d745f3500d636a62f64f0a' +
            'b3bae548aa53d423b0d1f27ebba6f5e5' +
            '673a081d70cce7acfc48'
        )
        computedOkm = self.HKDF(
            hashlib.sha1,
            ikm,
            length
        )
        if (computedOkm != okm):
            raise CryptoTestFailedException

    def HMACTestVector(self):
        # HMAC test vector From RFC 4231 (Test Case 1)
        key = '\x0b' * 20
        data = 'Hi There'
        correct = 'b0344c61d8db38535ca8afceaf0bf12b881dc200c9833da726e9376c2e32cff7'
        h = hmac.new(
            key,
            data,
            self.HASH_FUNCTION
        )
        if (h.hexdigest() != correct):
            raise CryptoTestFailedException

    def AESTestVector(self):
        # AES CBC mode test vector from NIST SP 800-38A
        key = self.hexToBytes('2b7e151628aed2a6abf7158809cf4f3c')
        iv = self.hexToBytes('000102030405060708090a0b0c0d0e0f')
        plainText = self.hexToBytes(
            '6bc1bee22e409f96e93d7e117393172a' +
            'ae2d8a571e03ac9c9eb76fac45af8e51' +
            '30c81c46a35ce411e5fbc1191a0a52ef' +
            'f69f2445df4f9b17ad2b417be66c3710'
        )
        cipherText = self.hexToBytes(
            '7649abac8119b246cee98e9b12e9197d' +
            '5086cb9b507219ee95db113a917678b2' +
            '73bed6b8e3c1743b7116e69e22229516' +
            '3ff1caa1681fac09120eca307586e1a7' +
            '8cb82807230e1321d3fae00d18cc2012'
            # Block due to padding. Not from NIST test vector.
            #    Padding Block: 10101010101010101010101010101010
            #    Ciphertext:    3ff1caa1681fac09120eca307586e1a7
            #               (+) 2fe1dab1780fbc19021eda206596f1b7
            #               AES 8cb82807230e1321d3fae00d18cc2012
        )
        computedCipherText = self.plainEncrypt(plainText, key, iv)
        if (computedCipherText != cipherText):
            raise CryptoTestFailedException

        computedPlainText = self.plainDecrypt(cipherText, key, iv)
        if (computedPlainText != plainText):
            raise CryptoTestFailedException

    # WARNING: Do not call this function on secrets. It creates side channels.
    def hexToBytes(self, hexString):
        return hexString.decode('hex')

    def ourSubStr(self, string, start, length=None):
        if (length is None):
            if (start >= 0):
                length = len(string) - start
            else:
                length = -start

        return string[start:(start + length)] if length else string[start:]

class InvalidCipherTextException(Exception):
    pass

class CryptoTestFailedException(Exception):
    pass

class CannotPerformOperationException(Exception):
    pass
