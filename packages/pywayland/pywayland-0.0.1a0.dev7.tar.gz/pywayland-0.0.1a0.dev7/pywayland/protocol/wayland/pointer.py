# -*- coding: utf-8 -*-
# This file has been autogenerated by the pywayland scanner

# Copyright © 2008-2011 Kristian Høgsberg
# Copyright © 2010-2011 Intel Corporation
# Copyright © 2012-2013 Collabora, Ltd.
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice (including the
# next paragraph) shall be included in all copies or substantial
# portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from pywayland.interface import Interface
from .surface import Surface

import enum


class Pointer(Interface):
    """Pointer input device

    The :class:`Pointer` interface represents one or more input devices, such
    as mice, which control the pointer location and pointer_focus of a seat.

    The :class:`Pointer` interface generates motion, enter and leave events for
    the surfaces that the pointer is located over, and button and axis events
    for button presses, button releases and scrolling.
    """
    name = "wl_pointer"
    version = 5

    error = enum.Enum("error", {
        "role": 0,
    })

    button_state = enum.Enum("button_state", {
        "released": 0,
        "pressed": 1,
    })

    axis = enum.Enum("axis", {
        "vertical_scroll": 0,
        "horizontal_scroll": 1,
    })

    axis_source = enum.Enum("axis_source", {
        "wheel": 0,
        "finger": 1,
        "continuous": 2,
    })


@Pointer.request("u?oii", [None, Surface, None, None])
def set_cursor(self, serial, surface, hotspot_x, hotspot_y):
    """Set the pointer surface

    Set the pointer surface, i.e., the surface that contains the pointer image
    (cursor). This request gives the surface the role of a cursor. If the
    surface already has another role, it raises a protocol error.

    The cursor actually changes only if the pointer focus for this device is
    one of the requesting client's surfaces or the surface parameter is the
    current pointer surface. If there was a previous surface set with this
    request it is replaced. If surface is NULL, the pointer image is hidden.

    The parameters hotspot_x and hotspot_y define the position of the pointer
    surface relative to the pointer location. Its top-left corner is always at
    (x, y) - (hotspot_x, hotspot_y), where (x, y) are the coordinates of the
    pointer location, in surface local coordinates.

    On surface.attach requests to the pointer surface, hotspot_x and hotspot_y
    are decremented by the x and y parameters passed to the request. Attach
    must be confirmed by :func:`Surface.commit()
    <pywayland.protocol.wayland.surface.Surface.commit>` as usual.

    The hotspot can also be updated by passing the currently set pointer
    surface to this request with new values for hotspot_x and hotspot_y.

    The current and pending input regions of the
    :class:`~pywayland.protocol.wayland.surface.Surface` are cleared, and
    :func:`Surface.set_input_region()
    <pywayland.protocol.wayland.surface.Surface.set_input_region>` is ignored
    until the :class:`~pywayland.protocol.wayland.surface.Surface` is no longer
    used as the cursor. When the use as a cursor ends, the current and pending
    input regions become undefined, and the
    :class:`~pywayland.protocol.wayland.surface.Surface` is unmapped.

    :param serial: serial of the enter event
    :type serial: `uint`
    :param surface:
    :type surface: :class:`~pywayland.protocol.wayland.surface.Surface` or `None`
    :param hotspot_x: x coordinate in surface-relative coordinates
    :type hotspot_x: `int`
    :param hotspot_y: y coordinate in surface-relative coordinates
    :type hotspot_y: `int`
    """
    self._marshal(0, serial, surface, hotspot_x, hotspot_y)


@Pointer.request("3", [])
def release(self):
    """Release the pointer object

    Using this request client can tell the server that it is not going to use
    the pointer object anymore.

    This request destroys the pointer proxy object, so user must not call
    :func:`Pointer.destroy()
    <pywayland.protocol.wayland.pointer.Pointer.destroy>` after using this
    request.
    """
    self._marshal(1)
    self._destroy()


@Pointer.event("uoff", [None, Surface, None, None])
def enter(self, serial, surface, surface_x, surface_y):
    """Enter event

    Notification that this seat's pointer is focused on a certain surface.

    When an seat's focus enters a surface, the pointer image is undefined and a
    client should respond to this event by setting an appropriate pointer image
    with the set_cursor request.

    :param serial:
    :type serial: `uint`
    :param surface:
    :type surface: :class:`~pywayland.protocol.wayland.surface.Surface`
    :param surface_x: x coordinate in surface-relative coordinates
    :type surface_x: `fixed`
    :param surface_y: y coordinate in surface-relative coordinates
    :type surface_y: `fixed`
    """
    self._post_event(0, serial, surface, surface_x, surface_y)


@Pointer.event("uo", [None, Surface])
def leave(self, serial, surface):
    """Leave event

    Notification that this seat's pointer is no longer focused on a certain
    surface.

    The leave notification is sent before the enter notification for the new
    focus.

    :param serial:
    :type serial: `uint`
    :param surface:
    :type surface: :class:`~pywayland.protocol.wayland.surface.Surface`
    """
    self._post_event(1, serial, surface)


@Pointer.event("uff", [None, None, None])
def motion(self, time, surface_x, surface_y):
    """Pointer motion event

    Notification of pointer location change. The arguments surface_x and
    surface_y are the location relative to the focused surface.

    :param time: timestamp with millisecond granularity
    :type time: `uint`
    :param surface_x: x coordinate in surface-relative coordinates
    :type surface_x: `fixed`
    :param surface_y: y coordinate in surface-relative coordinates
    :type surface_y: `fixed`
    """
    self._post_event(2, time, surface_x, surface_y)


@Pointer.event("uuuu", [None, None, None, None])
def button(self, serial, time, button, state):
    """Pointer button event

    Mouse button click and release notifications.

    The location of the click is given by the last motion or enter event. The
    time argument is a timestamp with millisecond granularity, with an
    undefined base.

    :param serial:
    :type serial: `uint`
    :param time: timestamp with millisecond granularity
    :type time: `uint`
    :param button:
    :type button: `uint`
    :param state:
    :type state: `uint`
    """
    self._post_event(3, serial, time, button, state)


@Pointer.event("uuf", [None, None, None])
def axis(self, time, axis, value):
    """Axis event

    Scroll and other axis notifications.

    For scroll events (vertical and horizontal scroll axes), the value
    parameter is the length of a vector along the specified axis in a
    coordinate space identical to those of motion events, representing a
    relative movement along the specified axis.

    For devices that support movements non-parallel to axes multiple axis
    events will be emitted.

    When applicable, for example for touch pads, the server can choose to emit
    scroll events where the motion vector is equivalent to a motion event
    vector.

    When applicable, clients can transform its view relative to the scroll
    distance.

    :param time: timestamp with millisecond granularity
    :type time: `uint`
    :param axis:
    :type axis: `uint`
    :param value:
    :type value: `fixed`
    """
    self._post_event(4, time, axis, value)


@Pointer.event("5", [])
def frame(self):
    """End of a pointer event sequence

    Indicates the end of a set of events that logically belong together. A
    client is expected to accumulate the data in all events within the frame
    before proceeding.

    All :class:`Pointer` events before a :func:`Pointer.frame` event belong
    logically together. For example, in a diagonal scroll motion the compositor
    will send an optional :func:`Pointer.axis_source` event, two
    :func:`Pointer.axis` events (horizontal and vertical) and finally a
    :func:`Pointer.frame` event. The client may use this information to
    calculate a diagonal vector for scrolling.

    When multiple :func:`Pointer.axis` events occur within the same frame, the
    motion vector is the combined motion of all events. When a
    :func:`Pointer.axis` and a :func:`Pointer.axis_stop` event occur within the
    same frame, this indicates that axis movement in one axis has stopped but
    continues in the other axis. When multiple :func:`Pointer.axis_stop` events
    occur within in the same frame, this indicates that these axes stopped in
    the same instance.

    A :func:`Pointer.frame` event is sent for every logical event group, even
    if the group only contains a single :class:`Pointer` event. Specifically, a
    client may get a sequence: motion, frame, button, frame, axis, frame,
    axis_stop, frame.

    The :func:`Pointer.enter` and :func:`Pointer.leave` events are logical
    events generated by the compositor and not the hardware. These events are
    also grouped by a :func:`Pointer.frame`. When a pointer moves from one
    surface to the another, a compositor should group the :func:`Pointer.leave`
    event within the same :func:`Pointer.frame`. However, a client must not
    rely on :func:`Pointer.leave` and :func:`Pointer.enter` being in the same
    :func:`Pointer.frame`. Compositor-specific policies may require the
    :func:`Pointer.leave` and :func:`Pointer.enter` event being split across
    multiple :func:`Pointer.frame` groups.
    """
    self._post_event(5)


@Pointer.event("5u", [None])
def axis_source(self, axis_source):
    """Axis source event

    Source information for scroll and other axes.

    This event does not occur on its own. It is sent before a
    :func:`Pointer.frame` event and carries the source information for all
    events within that frame.

    The source specifies how this event was generated. If the source is
    :func:`Pointer.axis_source`.finger, a :func:`Pointer.axis_stop` event will
    be sent when the user lifts the finger off the device.

    If the source is :class:`Pointer` axis_source.wheel or
    :func:`Pointer.axis_source`.continuous, a :func:`Pointer.axis_stop` event
    may or may not be sent. Whether a compositor sends a axis_stop event for
    these sources is hardware-specific and implementation-dependent; clients
    must not rely on receiving an axis_stop event for these scroll sources and
    should treat scroll sequences from these scroll sources as unterminated by
    default.

    This event is optional. If the source is unknown for a particular axis
    event sequence, no event is sent. Only one :func:`Pointer.axis_source`
    event is permitted per frame.

    The order of :func:`Pointer.axis_discrete` and :func:`Pointer.axis_source`
    is not guaranteed.

    :param axis_source:
    :type axis_source: `uint`
    """
    self._post_event(6, axis_source)


@Pointer.event("5uu", [None, None])
def axis_stop(self, time, axis):
    """Axis stop event

    Stop notification for scroll and other axes.

    For some :func:`Pointer.axis_source` types, a :func:`Pointer.axis_stop`
    event is sent to notify a client that the axis sequence has terminated.
    This enables the client to implement kinetic scrolling. See the
    :func:`Pointer.axis_source` documentation for information on when this
    event may be generated.

    Any :func:`Pointer.axis` events with the same axis_source after this event
    should be considered as the start of a new axis motion.

    The timestamp is to be interpreted identical to the timestamp in the
    :func:`Pointer.axis` event. The timestamp value may be the same as a
    preceeding :func:`Pointer.axis` event.

    :param time: timestamp with millisecond granularity
    :type time: `uint`
    :param axis: the axis stopped with this event
    :type axis: `uint`
    """
    self._post_event(7, time, axis)


@Pointer.event("5ui", [None, None])
def axis_discrete(self, axis, discrete):
    """Axis click event

    Discrete step information for scroll and other axes.

    This event carries the axis value of the :func:`Pointer.axis` event in
    discrete steps (e.g. mouse wheel clicks).

    This event does not occur on its own, it is coupled with a
    :func:`Pointer.axis` event that represents this axis value on a continuous
    scale. The protocol guarantees that each axis_discrete event is always
    followed by exactly one axis event with the same axis number within the
    same :func:`Pointer.frame`. Note that the protocol allows for other events
    to occur between the axis_discrete and its coupled axis event, including
    other axis_discrete or axis events.

    This event is optional; continuous scrolling devices like two-finger
    scrolling on touchpads do not have discrete steps and do not generate this
    event.

    The discrete value carries the directional information. e.g. a value of -2
    is two steps towards the negative direction of this axis.

    The axis number is identical to the axis number in the associate axis
    event.

    The order of :func:`Pointer.axis_discrete` and :func:`Pointer.axis_source`
    is not guaranteed.

    :param axis:
    :type axis: `uint`
    :param discrete:
    :type discrete: `int`
    """
    self._post_event(8, axis, discrete)


Pointer._gen_c()
