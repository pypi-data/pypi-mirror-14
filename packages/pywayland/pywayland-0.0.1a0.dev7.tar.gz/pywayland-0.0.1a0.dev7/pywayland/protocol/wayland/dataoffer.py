# -*- coding: utf-8 -*-
# This file has been autogenerated by the pywayland scanner

# Copyright © 2008-2011 Kristian Høgsberg
# Copyright © 2010-2011 Intel Corporation
# Copyright © 2012-2013 Collabora, Ltd.
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice (including the
# next paragraph) shall be included in all copies or substantial
# portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from pywayland.interface import Interface

import enum


class DataOffer(Interface):
    """Offer to transfer data

    A :class:`DataOffer` represents a piece of data offered for transfer by
    another client (the source client).  It is used by the copy-and-paste and
    drag-and-drop mechanisms.  The offer describes the different mime types
    that the data can be converted to and provides the mechanism for
    transferring the data directly from the source client.
    """
    name = "wl_data_offer"
    version = 3

    error = enum.Enum("error", {
        "invalid_finish": 0,
        "invalid_action_mask": 1,
        "invalid_action": 2,
        "invalid_offer": 3,
    })


@DataOffer.request("u?s", [None, None])
def accept(self, serial, mime_type):
    """Accept one of the offered mime types

    Indicate that the client can accept the given mime type, or NULL for not
    accepted.

    For objects of version 2 or older, this request is used by the client to
    give feedback whether the client can receive the given mime type, or NULL
    if none is accepted; the feedback does not determine whether the drag-and-
    drop operation succeeds or not.

    For objects of version 3 or newer, this request determines the final result
    of the drag-and-drop operation. If the end result is that no mime types
    were accepted, the drag-and-drop operation will be cancelled and the
    corresponding drag source will receive :func:`DataSource.cancelled()
    <pywayland.protocol.wayland.datasource.DataSource.cancelled>`. Clients may
    still use this event in conjunction with :func:`DataSource.action()
    <pywayland.protocol.wayland.datasource.DataSource.action>` for feedback.

    :param serial:
    :type serial: `uint`
    :param mime_type:
    :type mime_type: `string` or `None`
    """
    self._marshal(0, serial, mime_type)


@DataOffer.request("sh", [None, None])
def receive(self, mime_type, fd):
    """Request that the data is transferred

    To transfer the offered data, the client issues this request and indicates
    the mime type it wants to receive.  The transfer happens through the passed
    file descriptor (typically created with the pipe system call).  The source
    client writes the data in the mime type representation requested and then
    closes the file descriptor.

    The receiving client reads from the read end of the pipe until EOF and then
    closes its end, at which point the transfer is complete.

    This request may happen multiple times for different mimetypes, both before
    and after :func:`DataDevice.drop()
    <pywayland.protocol.wayland.datadevice.DataDevice.drop>`. Drag-and-drop
    destination clients may preemptively fetch data or examine it more closely
    to determine acceptance.

    :param mime_type:
    :type mime_type: `string`
    :param fd:
    :type fd: `fd`
    """
    self._marshal(1, mime_type, fd)


@DataOffer.request("", [])
def destroy(self):
    """Destroy data offer

    Destroy the data offer.
    """
    self._marshal(2)
    self._destroy()


@DataOffer.request("3", [])
def finish(self):
    """The offer will no longer be used

    Notifies the compositor that the drag destination successfully finished the
    drag-and-drop operation.

    Upon receiving this request, the compositor will emit
    :func:`DataSource.dnd_finished()
    <pywayland.protocol.wayland.datasource.DataSource.dnd_finished>` on the
    drag source client.

    It is a client error to perform other requests than
    :func:`DataOffer.destroy` after this one. It is also an error to perform
    this request after a NULL mime type has been set in
    :func:`DataOffer.accept` or no action was received through
    :func:`DataOffer.action`.
    """
    self._marshal(3)


@DataOffer.request("3uu", [None, None])
def set_actions(self, dnd_actions, preferred_action):
    """Set the available/preferred drag-and-drop actions

    Sets the actions that the destination side client supports for this
    operation. This request may trigger the emission of
    :func:`DataSource.action()
    <pywayland.protocol.wayland.datasource.DataSource.action>` and
    :func:`DataOffer.action` events if the compositor need to change the
    selected action.

    This request can be called multiple times throughout the drag-and-drop
    operation, typically in response to :func:`DataDevice.enter()
    <pywayland.protocol.wayland.datadevice.DataDevice.enter>` or
    :func:`DataDevice.motion()
    <pywayland.protocol.wayland.datadevice.DataDevice.motion>` events.

    This request determines the final result of the drag-and-drop operation. If
    the end result is that no action is accepted, the drag source will receive
    :func:`DragSource.cancelled()
    <pywayland.protocol.wayland.dragsource.DragSource.cancelled>`.

    The dnd_actions argument must contain only values expressed in the
    :func:`DataDeviceManager.dnd_actions() <pywayland.protocol.wayland.datadevi
    cemanager.DataDeviceManager.dnd_actions>` enum, and the preferred_action
    argument must only contain one of those values set, otherwise it will
    result in a protocol error.

    While managing an "ask" action, the destination drag-and-drop client may
    perform further :func:`DataOffer.receive` requests, and is expected to
    perform one last :func:`DataOffer.set_actions` request with a preferred
    action other than "ask" (and optionally :func:`DataOffer.accept`) before
    requesting :func:`DataOffer.finish`, in order to convey the action selected
    by the user. If the preferred action is not in the
    :func:`DataOffer.source_actions` mask, an error will be raised.

    If the "ask" action is dismissed (e.g. user cancellation), the client is
    expected to perform :func:`DataOffer.destroy` right away.

    This request can only be made on drag-and-drop offers, a protocol error
    will be raised otherwise.

    :param dnd_actions:
    :type dnd_actions: `uint`
    :param preferred_action:
    :type preferred_action: `uint`
    """
    self._marshal(4, dnd_actions, preferred_action)


@DataOffer.event("s", [None])
def offer(self, mime_type):
    """Advertise offered mime type

    Sent immediately after creating the :class:`DataOffer` object.  One event
    per offered mime type.

    :param mime_type:
    :type mime_type: `string`
    """
    self._post_event(0, mime_type)


@DataOffer.event("3u", [None])
def source_actions(self, source_actions):
    """Notify the source-side available actions

    This event indicates the actions offered by the data source. It will be
    sent right after :func:`DataDevice.enter()
    <pywayland.protocol.wayland.datadevice.DataDevice.enter>`, or anytime the
    source side changes its offered actions through
    :func:`DataSource.set_actions()
    <pywayland.protocol.wayland.datasource.DataSource.set_actions>`.

    :param source_actions:
    :type source_actions: `uint`
    """
    self._post_event(1, source_actions)


@DataOffer.event("3u", [None])
def action(self, dnd_action):
    """Notify the selected action

    This event indicates the action selected by the compositor after matching
    the source/destination side actions. Only one action (or none) will be
    offered here.

    This event can be emitted multiple times during the drag-and-drop operation
    in response to destination side action changes through
    :func:`DataOffer.set_actions`.

    This event will no longer be emitted after :func:`DataDevice.drop()
    <pywayland.protocol.wayland.datadevice.DataDevice.drop>` happened on the
    drag-and-drop destination, the client must honor the last action received,
    or the last preferred one set through :func:`DataOffer.set_actions` when
    handling an "ask" action.

    Compositors may also change the selected action on the fly, mainly in
    response to keyboard modifier changes during the drag-and-drop operation.

    The most recent action received is always the valid one. Prior to receiving
    :func:`DataDevice.drop()
    <pywayland.protocol.wayland.datadevice.DataDevice.drop>`, the chosen action
    may change (e.g. due to keyboard modifiers being pressed). At the time of
    receiving :func:`DataDevice.drop()
    <pywayland.protocol.wayland.datadevice.DataDevice.drop>` the drag-and-drop
    destination must honor the last action received.

    Action changes may still happen after :func:`DataDevice.drop()
    <pywayland.protocol.wayland.datadevice.DataDevice.drop>`, especially on
    "ask" actions, where the drag-and-drop destination may choose another
    action afterwards. Action changes happening at this stage are always the
    result of inter-client negotiation, the compositor shall no longer be able
    to induce a different action.

    Upon "ask" actions, it is expected that the drag-and-drop destination may
    potentially choose different a different action and/or mime type, based on
    :func:`DataOffer.source_actions` and finally chosen by the user (e.g.
    popping up a menu with the available options). The final
    :func:`DataOffer.set_actions` and :func:`DataOffer.accept` requests must
    happen before the call to :func:`DataOffer.finish`.

    :param dnd_action:
    :type dnd_action: `uint`
    """
    self._post_event(2, dnd_action)


DataOffer._gen_c()
