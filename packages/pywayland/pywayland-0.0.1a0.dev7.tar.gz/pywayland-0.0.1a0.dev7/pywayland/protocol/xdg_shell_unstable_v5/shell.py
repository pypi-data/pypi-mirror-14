# -*- coding: utf-8 -*-
# This file has been autogenerated by the pywayland scanner

# Copyright © 2008-2013 Kristian Høgsberg
# Copyright © 2013      Rafael Antognolli
# Copyright © 2013      Jasper St. Pierre
# Copyright © 2010-2013 Intel Corporation
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice (including the next
# paragraph) shall be included in all copies or substantial portions of the
# Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.

from pywayland.interface import Interface
from ..wayland.seat import Seat as wl_Seat
from ..wayland.surface import Surface as wl_Surface
from .popup import Popup
from .surface import Surface

import enum


class Shell(Interface):
    """Create desktop-style surfaces

    xdg_shell allows clients to turn a
    :class:`~pywayland.protocol.wayland.surface.Surface` into a "real window"
    which can be dragged, resized, stacked, and moved around by the user.
    Everything about this interface is suited towards traditional desktop
    environments.
    """
    name = "xdg_shell"
    version = 1

    version = enum.Enum("version", {
        "current": 5,
    })

    error = enum.Enum("error", {
        "role": 0,
        "defunct_surfaces": 1,
        "not_the_topmost_popup": 2,
        "invalid_popup_parent": 3,
    })


@Shell.request("", [])
def destroy(self):
    """Destroy xdg_shell

    Destroy this xdg_shell object.

    Destroying a bound xdg_shell object while there are surfaces still alive
    created by this xdg_shell object instance is illegal and will result in a
    protocol error.
    """
    self._marshal(0)
    self._destroy()


@Shell.request("i", [None])
def use_unstable_version(self, version):
    """Enable use of this unstable version

    Negotiate the unstable version of the interface.  This mechanism is in
    place to ensure client and server agree on the unstable versions of the
    protocol that they speak or exit cleanly if they don't agree.  This request
    will go away once the xdg-shell protocol is stable.

    :param version:
    :type version: `int`
    """
    self._marshal(1, version)


@Shell.request("no", [Surface, wl_Surface])
def get_xdg_surface(self, surface):
    """Create a shell surface from a surface

    This creates an xdg_surface for the given surface and gives it the
    xdg_surface role. A :class:`~pywayland.protocol.wayland.surface.Surface`
    can only be given an xdg_surface role once. If get_xdg_surface is called
    with a :class:`~pywayland.protocol.wayland.surface.Surface` that already
    has an active xdg_surface associated with it, or if it had any other role,
    an error is raised.

    See the documentation of xdg_surface for more details about what an
    xdg_surface is and how it is used.

    :param surface:
    :type surface: :class:`~pywayland.protocol.wayland.surface.Surface`
    :returns: :class:`~pywayland.protocol.xdg_shell_unstable_v5.surface.Surface`
    """
    id = self._marshal_constructor(2, Surface, surface)
    return id


@Shell.request("nooouii", [Popup, wl_Surface, wl_Surface, wl_Seat, None, None, None])
def get_xdg_popup(self, surface, parent, seat, serial, x, y):
    """Create a popup for a surface

    This creates an xdg_popup for the given surface and gives it the xdg_popup
    role. A :class:`~pywayland.protocol.wayland.surface.Surface` can only be
    given an xdg_popup role once. If get_xdg_popup is called with a
    :class:`~pywayland.protocol.wayland.surface.Surface` that already has an
    active xdg_popup associated with it, or if it had any other role, an error
    is raised.

    This request must be used in response to some sort of user action like a
    button press, key press, or touch down event.

    See the documentation of xdg_popup for more details about what an xdg_popup
    is and how it is used.

    :param surface:
    :type surface: :class:`~pywayland.protocol.wayland.surface.Surface`
    :param parent:
    :type parent: :class:`~pywayland.protocol.wayland.surface.Surface`
    :param seat: the :class:`~pywayland.protocol.wayland.seat.Seat` of the user event
    :type seat: :class:`~pywayland.protocol.wayland.seat.Seat`
    :param serial: the serial of the user event
    :type serial: `uint`
    :param x:
    :type x: `int`
    :param y:
    :type y: `int`
    :returns: :class:`~pywayland.protocol.xdg_shell_unstable_v5.popup.Popup`
    """
    id = self._marshal_constructor(3, Popup, surface, parent, seat, serial, x, y)
    return id


@Shell.request("u", [None])
def pong(self, serial):
    """Respond to a ping event

    A client must respond to a ping event with a pong request or the client may
    be deemed unresponsive.

    :param serial: serial of the ping event
    :type serial: `uint`
    """
    self._marshal(4, serial)


@Shell.event("u", [None])
def ping(self, serial):
    """Check if the client is alive

    The ping event asks the client if it's still alive. Pass the serial
    specified in the event back to the compositor by sending a "pong" request
    back with the specified serial.

    Compositors can use this to determine if the client is still alive. It's
    unspecified what will happen if the client doesn't respond to the ping
    request, or in what timeframe. Clients should try to respond in a
    reasonable amount of time.

    A compositor is free to ping in any way it wants, but a client must always
    respond to any xdg_shell object it created.

    :param serial: pass this to the pong request
    :type serial: `uint`
    """
    self._post_event(0, serial)


Shell._gen_c()
