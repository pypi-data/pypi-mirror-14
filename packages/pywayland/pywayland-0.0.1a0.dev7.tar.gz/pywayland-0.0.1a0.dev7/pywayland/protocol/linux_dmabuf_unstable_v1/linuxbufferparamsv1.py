# -*- coding: utf-8 -*-
# This file has been autogenerated by the pywayland scanner

# Copyright Â© 2014, 2015 Collabora, Ltd.
#
# Permission to use, copy, modify, distribute, and sell this
# software and its documentation for any purpose is hereby granted
# without fee, provided that the above copyright notice appear in
# all copies and that both that copyright notice and this permission
# notice appear in supporting documentation, and that the name of
# the copyright holders not be used in advertising or publicity
# pertaining to distribution of the software without specific,
# written prior permission.  The copyright holders make no
# representations about the suitability of this software for any
# purpose.  It is provided "as is" without express or implied
# warranty.
#
# THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
# SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
# FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
# SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
# AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
# ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
# THIS SOFTWARE.

from pywayland.interface import Interface
from ..wayland.buffer import Buffer as wl_Buffer

import enum


class LinuxBufferParamsV1(Interface):
    """Parameters for creating a dmabuf-based :class:`~pywayland.protocol.wayland.buffer.Buffer`

    This temporary object is a collection of dmabufs and other parameters that
    together form a single logical buffer. The temporary object may eventually
    create one :class:`~pywayland.protocol.wayland.buffer.Buffer` unless
    cancelled by destroying it before requesting 'create'.

    Single-planar formats only require one dmabuf, however multi-planar formats
    may require more than one dmabuf. For all formats, 'add' request must be
    called once per plane (even if the underlying dmabuf fd is identical).

    You must use consecutive plane indices ('plane_idx' argument for 'add')
    from zero to the number of planes used by the drm_fourcc format code. All
    planes required by the format must be given exactly once, but can be given
    in any order. Each plane index can be set only once.
    """
    name = "zwp_linux_buffer_params_v1"
    version = 1

    error = enum.Enum("error", {
        "already_used": 0,
        "plane_idx": 1,
        "plane_set": 2,
        "incomplete": 3,
        "invalid_format": 4,
        "invalid_dimensions": 5,
        "out_of_bounds": 6,
    })

    flags = enum.Enum("flags", {
        "y_invert": 1,
        "interlaced": 2,
        "bottom_first": 4,
    })


@LinuxBufferParamsV1.request("", [])
def destroy(self):
    """Delete this object, used or not

    Cleans up the temporary data sent to the server for dmabuf-based
    :class:`~pywayland.protocol.wayland.buffer.Buffer` creation.
    """
    self._marshal(0)
    self._destroy()


@LinuxBufferParamsV1.request("huuuuu", [None, None, None, None, None, None])
def add(self, fd, plane_idx, offset, stride, modifier_hi, modifier_lo):
    """Add a dmabuf to the temporary set

    This request adds one dmabuf to the set in this zwp_linux_buffer_params_v1.

    The 64-bit unsigned value combined from modifier_hi and modifier_lo is the
    dmabuf layout modifier. DRM AddFB2 ioctl calls this the fb modifier, which
    is defined in drm_mode.h of Linux UAPI. This is an opaque token. Drivers
    use this token to express tiling, compression, etc. driver-specific
    modifications to the base format defined by the DRM fourcc code.

    This request raises the PLANE_IDX error if plane_idx is too large. The
    error PLANE_SET is raised if attempting to set a plane that was already
    set.

    :param fd: dmabuf fd
    :type fd: `fd`
    :param plane_idx: plane index
    :type plane_idx: `uint`
    :param offset: offset in bytes
    :type offset: `uint`
    :param stride: stride in bytes
    :type stride: `uint`
    :param modifier_hi: high 32 bits of layout modifier
    :type modifier_hi: `uint`
    :param modifier_lo: low 32 bits of layout modifier
    :type modifier_lo: `uint`
    """
    self._marshal(1, fd, plane_idx, offset, stride, modifier_hi, modifier_lo)


@LinuxBufferParamsV1.request("iiuu", [None, None, None, None])
def create(self, width, height, format, flags):
    """Create a :class:`~pywayland.protocol.wayland.buffer.Buffer` from the given dmabufs

    This asks for creation of a
    :class:`~pywayland.protocol.wayland.buffer.Buffer` from the added dmabuf
    buffers. The :class:`~pywayland.protocol.wayland.buffer.Buffer` is not
    created immediately but returned via the 'created' event if the dmabuf
    sharing succeeds. The sharing may fail at runtime for reasons a client
    cannot predict, in which case the 'failed' event is triggered.

    The 'format' argument is a DRM_FORMAT code, as defined by the libdrm's
    drm_fourcc.h. The Linux kernel's DRM sub-system is the authoritative source
    on how the format codes should work.

    The 'flags' is a bitfield of the flags defined in enum "flags". 'y_invert'
    means the that the image needs to be y-flipped.

    Flag 'interlaced' means that the frame in the buffer is not progressive as
    usual, but interlaced. An interlaced buffer as supported here must always
    contain both top and bottom fields. The top field always begins on the
    first pixel row. The temporal ordering between the two fields is top field
    first, unless 'bottom_first' is specified. It is undefined whether
    'bottom_first' is ignored if 'interlaced' is not set.

    This protocol does not convey any information about field rate, duration,
    or timing, other than the relative ordering between the two fields in one
    buffer. A compositor may have to estimate the intended field rate from the
    incoming buffer rate. It is undefined whether the time of receiving
    :func:`Surface.commit()
    <pywayland.protocol.wayland.surface.Surface.commit>` with a new buffer
    attached, applying the :class:`~pywayland.protocol.wayland.surface.Surface`
    state, :func:`Surface.frame()
    <pywayland.protocol.wayland.surface.Surface.frame>` callback trigger,
    presentation, or any other point in the compositor cycle is used to measure
    the frame or field times. There is no support for detecting missed or late
    frames/fields/buffers either, and there is no support whatsoever for
    cooperating with interlaced compositor output.

    The composited image quality resulting from the use of interlaced buffers
    is explicitly undefined. A compositor may use elaborate hardware features
    or software to deinterlace and create progressive output frames from a
    sequence of interlaced input buffers, or it may produce substandard image
    quality. However, compositors that cannot guarantee reasonable image
    quality in all cases are recommended to just reject all interlaced buffers.

    Any argument errors, including non-positive width or height, mismatch
    between the number of planes and the format, bad format, bad offset or
    stride, may be indicated by fatal protocol errors: INCOMPLETE,
    INVALID_FORMAT, INVALID_DIMENSIONS, OUT_OF_BOUNDS.

    Dmabuf import errors in the server that are not obvious client bugs are
    returned via the 'failed' event as non-fatal. This allows attempting dmabuf
    sharing and falling back in the client if it fails.

    This request can be sent only once in the object's lifetime, after which
    the only legal request is destroy. This object should be destroyed after
    issuing 'create' request. Attempting to use this object after issuing
    'create' raises ALREADY_USED protocol error.

    It is not mandatory to issue 'create'. If a client wants to cancel the
    buffer creation, it can just destroy this object.

    :param width: base plane width in pixels
    :type width: `int`
    :param height: base plane height in pixels
    :type height: `int`
    :param format: DRM_FORMAT code
    :type format: `uint`
    :param flags: see enum flags
    :type flags: `uint`
    """
    self._marshal(2, width, height, format, flags)


@LinuxBufferParamsV1.event("n", [wl_Buffer])
def created(self, buffer):
    """Buffer creation succeeded

    This event indicates that the attempted buffer creation was successful. It
    provides the new :class:`~pywayland.protocol.wayland.buffer.Buffer`
    referencing the dmabuf(s).

    Upon receiving this event, the client should destroy the
    zlinux_dmabuf_params object.

    :param buffer: the newly created :class:`~pywayland.protocol.wayland.buffer.Buffer`
    :type buffer: :class:`~pywayland.protocol.wayland.buffer.Buffer`
    """
    self._post_event(0, buffer)


@LinuxBufferParamsV1.event("", [])
def failed(self):
    """Buffer creation failed

    This event indicates that the attempted buffer creation has failed. It
    usually means that one of the dmabuf constraints has not been fulfilled.

    Upon receiving this event, the client should destroy the
    zlinux_buffer_params object.
    """
    self._post_event(1)


LinuxBufferParamsV1._gen_c()
