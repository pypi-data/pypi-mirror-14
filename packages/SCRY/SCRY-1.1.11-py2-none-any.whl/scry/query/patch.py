# A small patch that circumvents raising errors when RDFlib encounters a
# ServiceGraphPattern in query algebras, by registering evalService to the
# rdf.plugins.sparqleval entry point, thereby being loaded into CUSTOM_EVALS.
#
# Also defines the ServiceHandler subclass of ContextHandler, which will be
# instantiated by SCRY upon encountering ServiceGraphPatterns while parsing the
# query algebra. When executed, ServiceHandlers compile and resolve a query
# using SPARQLWrapper. Where applicable, variable bindings generated by other
# context handlers will be submitted in a Values clause. Inclusion in a Values
# clause only occurs if a variable is 1) projected by the ServiceHandler's
# reconstructed query and 2) bound by context handlers whose inputs are
# independent of other variables projected by said query.
#
# Later, when resolving the algebra, evalService will 1) determine which
# ServiceHandler contains its results, and 2) return them in a format compatible
# with RDFlib's evalQuery (i.e. the recursive evalPart stack). (1) is achieved
# by popping elements out of an ordered list injected into the query context,
# containing all of a QueryHandler's ServiceHandler objects in the order they
# were instantiated. The bindings for (2) are obtained through said objects'
# get_results() method.
#
# NOTE: This patch ONLY supports Service statements which involve a (sub)select
# query. The reconstructed query will try to cast a ServiceGraphPattern's
# algebra in a SELECT form, which may cause strange behaviour if 

from SPARQLWrapper       import SPARQLWrapper, JSON
from rdflib.plugins.sparql.sparql import FrozenBindings
from rdflib.term         import Literal, URIRef, Variable
from scry.query.contexts import ContextHandler



def evalService(ctx, part):
    if part.name != 'ServiceGraphPattern':
        raise NotImplementedError
    else:
        handler = ctx.prologue.service_handlers.pop(0)
        return handler.format_bindings(ctx)



class ServiceHandler(ContextHandler):
    
    def __init__(self, query_handler, algebra, query):
        super(ServiceHandler,self).__init__(query_handler)        
        self.algebra        = algebra
        self.query          = query
        self.projected_vars = set()
        self.results        = None
    
    
    def set_bound_vars(self, vars_from_others=None):
        if vars_from_others:
            self.parse_algebra()
            v_other = set([v for v in getattr(vars_from_others,'__iter__',list)()])
            for v in self.bound_vars.intersection(v_other):
                    self.input_vars.add(v)
            for v in self.projected_vars - v_other:
                    self.output_vars.add(v)
    
    
    def parse_algebra(self):
        def add_vars(part):
            for k in getattr(part,'keys',list)():
                if k == '_vars':
                    for v in part[k]: self.projected_vars.add(v)
                else:
                    add_vars(part[k])

        q = self.query
        q = q[q.find('{')+1:-1].strip()
        if q[:6].upper() != 'SELECT':
            q = 'SELECT * {%s}' % q
            add_vars(self.algebra)
        else:
            self.projected_vars = set(self.algebra._vars)
        self.bound_vars = set(self.algebra._vars)
        self.endpoint   = self.algebra.term
        self.query      = q
        
        
    def execute(self):
        q = self.query_handler.prefixes + '\n\n' + self.query
        # If applicable, add a VALUES clause for variables bound by other context handlers
        if self.dependencies:
            dep_binds = [dep.bindings for dep in self.dependencies]
            in_vars   = [var.encode() for var in self.input_vars]
            inputs    = self.merge_and_filter(in_vars,dep_binds)
            print inputs

            #closer = q.rfind('}')
            #q = q[:closer] + values + q[closer:]
        w = SPARQLWrapper(self.endpoint)
        w.setQuery(q)
        w.setReturnFormat(JSON)

        self.results  = w.query().convert()
        self.format_results()
        self.executed = True
        
    
    def format_results(self):
        r    = self.results
        head = {v:Variable(v) for v in r['head']['vars']}

        for pv in [v.encode() for v in self.projected_vars]:
            if pv not in head:
                print 'Warning: expected bindings for %s in SERVICE results, but none were found' % pv
        
        for b in r['results']['bindings']:
            d = dict()
            for h in head:
                v = b[h]['value']
                H = head[h]
                if b[h]['type'] == 'uri': d[H] = URIRef(v)
                else:
                    try:
                        d[H] = Literal(v,datatype=URIRef(b[h]['datatype']))
                    except KeyError:
                        d[H] = Literal(v)
            self.bindings.append(d)


    def format_bindings(self,ctx):
        # Reformat self.bindings so that the returned objects mimics something
        # that would be returned by rdflib.plugins.sparql.evaluate.evalOrderBy
        # to evalProject, so as to succesfully resolve an algebra.
        return [FrozenBindings(ctx, row) for row in self.bindings]