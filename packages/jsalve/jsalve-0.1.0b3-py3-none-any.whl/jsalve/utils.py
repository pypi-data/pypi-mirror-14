"""A module of JSON API utilities."""
import inflection
from collections import OrderedDict


def is_valid_resource_representation(resource, create=False):
    """
    Checks if resource is a valid *resource object* or *resource identifier*.

    Only checks the member properties, **not** the values assigned to
    the properties.

    Args:
        resource: The resource object checked
        create: If set to ``True``, denotes the resource is part of a
            create operation, which means the ``id`` members is not required
            as it may be generated by the server.

    Returns
        bool: ``True`` if it follows the JSON API resource format.
            ``False`` otherwise.
    """
    if create:
        return True if 'type' in resource else False
    else:
        members = ('id', 'type')
        for member in members:
            if member not in resource:
                return False
        return True


def is_valid_primary_data(primary_data, collection=False):
    """
    Checks candidate primary data for valid structure.

    Args:
        primary_data: Candidate data
        collection (bool): Whether the primary data is supposed to be
            a single resource or a collection of resources

    Returns:
        bool: ``True`` if it meets JSON API primary data requirements.
            ``False`` otherwise.
    """
    if collection:
        if isinstance(primary_data, list):
            if len(primary_data) == 0:
                return True
            else:
                for resource in primary_data:
                    if not is_valid_resource_representation(resource):
                        return False
                return True
    else:
        if isinstance(primary_data, dict):
            return is_valid_resource_representation(primary_data)
        if primary_data is None:
            return True
    return False


def is_valid_top_level(document, collection=False):
    """
    Checks candidate JSON API document for valid top-level
    structure.

    Args:
        document: A candidate JSON API document
        collection (bool): Whether the primary data is supposed to be
            a single resource or a collection of resources

    Raises:
        TypeError: If document is not an iterable.

    Returns:
        bool: ``True`` if it meets JSON API top-level specification.
            ``False`` otherwise.

    """
    try:
        if 'data' in document and 'errors' in document:
            return False
        if 'included' in document and 'data' not in document:
            return False
        if 'data' in document:
            primary_data_validation = is_valid_primary_data(document['data'], collection)
            if 'included' in document and not isinstance(document['included'], list):
                return False
            return primary_data_validation
        if 'errors' in document:
            return True if isinstance(document['errors'], list) else False
        if 'meta' in document:
            return True if isinstance(document['meta'], dict) else False
        return False
    except TypeError:
        return False


def to_dasherized_plural(name):
    """
    Pluralizes a name, as well as transforming camelCase
    name into dasherized formatting
    """
    plural = inflection.pluralize(name)
    underscore = inflection.underscore(plural)
    dasherized = inflection.dasherize(underscore)
    return dasherized


def format_value(value, format_type='dasherize'):
    """
    Alters the format of a string value.  This is useful in
    ensuring that the keys representing serialized model field names
    are in the proper format.

    Note: `camelize` does not uppercase the first letter. Use
    `capitalize` for camel-casing that capitalizes the first letter.
    """
    if format_type == 'dasherize':
        # 2 steps because inflection library does not
        # directly dasherize camelCase
        value = inflection.underscore(value)
        value = inflection.dasherize(value)
    elif format_type == 'camelize':
        value = inflection.camelize(value, False)
    elif format_type == 'capitalize':
        value = inflection.camelize(value)
    elif format_type == 'underscore':
        value = inflection.underscore(value)
    return value


def format_keys(obj, format_type='dasherize'):
    """
    Passed dict/list gets its keys transformed. The default target format is
    dasherize, as this matches JSON API conventions.
    """
    if isinstance(obj, dict):
        with_new_keys = OrderedDict()
        for key, data in obj.items():
            if format_type == 'dasherize':
                with_new_keys[format_value(key)] = data
            elif format_type == 'camelize':
                with_new_keys[format_value(key, 'camelize')] = data
            elif format_type == 'underscore':
                with_new_keys[format_value(key, 'underscore')] = data
        return with_new_keys
    if isinstance(obj, list):
        return [format_keys(item, format_type) for item in obj]
    else:
        return obj


def format_resource(obj, format_type='dasherize'):
    """
    Passed dict/list gets its keys and values transformed to a new format.
    The default is dasherize, as this matches JSON API conventions.
    """
    if isinstance(obj, dict):
        formatted = OrderedDict()
        for field_name, data in obj.items():
            if format_type == 'dasherize':
                formatted[format_value(field_name)] = format_keys(data, format_type)
            elif format_type == 'camelize':
                formatted[inflection.camelize(field_name, False)] = format_keys(data, format_type)
            elif format_type == 'underscore':
                formatted[inflection.underscore(field_name)] = format_keys(data, format_type)
        return formatted
    if isinstance(obj, list):
        return [format_keys(item, format_type) for item in obj]
    else:
        return obj

