# import logging
import numpy as np
from .tissue import Tissue
from bs4 import BeautifulSoup

def from_SimPT(xml_string):
    """
    Returns a PyPTS.Tissue object created from a SimPT compatible XML
    description of a cellular tissue provided as a string.
    """
    soup = BeautifulSoup(xml_string, 'xml')

    # Empty tissue to build up with info from XML
    t = Tissue()

    # NODES -------------------------------------------------------------------
    nodes_xy = []
    for node in soup.find('mesh').find('nodes').findAll('node'):
        nodes_xy.append([
            float(node.find('x').text), float(node.find('y').text)
        ])
    t.nodes_xy = np.array(nodes_xy)
    t.num_nodes = t.nodes_xy.shape[0]
    t.nodes_id = np.arange(t.num_nodes)

    # CELLS -------------------------------------------------------------------
    cells_nodes = []
    cells_walls = []
    cells_chems = []
    for cell in soup.find('mesh').find('cells').findAll('cell'):
        # Cell nodes
        cell_nodes = [
            int(node.text) for node in cell.find('node_array').findAll('node')
        ]
        cells_nodes.append(cell_nodes)
        # Cell walls
        cell_walls = [
            int(wall.text) for wall in cell.find('wall_array').findAll('wall')
        ]
        cells_walls.append(cell_walls)
        # Cell attributes (chemicals only for now)
        cell_chems = [
            float(chem.text) for chem in cell.find('attributes').findAll('chemical')
        ]
        cells_chems.append(cell_chems)

    t.num_cells = len(cells_nodes)
    t.cells_id = np.arange(t.num_cells)
    t.cells_nodes = [np.array(_, dtype=np.int32) for _ in cells_nodes]
    t.cells_num_nodes = np.array([len(_) for _ in cells_nodes],
                                 dtype=np.int32)
    t.cells_walls = [np.array(_, dtype=np.int32) for _ in cells_walls]
    t.cells_num_walls = np.array([len(_) for _ in cells_walls],
                                 dtype=np.int32)

    # Convert cells_chems into attributes:
    cells_chems = np.array(cells_chems)
    nchems = cells_chems.shape[1]
    for i in xrange(nchems):
        t.cells_attributes['chem_{}'.format(i)] = cells_chems[:,i]

    # WALLS -------------------------------------------------------------------
    walls_cells = []
    walls_nodes = []
    for wall in soup.find('mesh').find('walls').findAll('wall'):
        wall_nodes = [int(wall.find('n1').text), int(wall.find('n2').text)]
        walls_nodes.append(wall_nodes)
        wall_cells = [int(wall.find('c1').text), int(wall.find('c2').text)]
        walls_cells.append(wall_cells)

    t.num_walls = len(walls_nodes)
    t.walls_id = np.arange(t.num_walls)
    t.walls_nodes = np.array(walls_nodes)
    t.walls_cells = np.array(walls_cells)

    t.prepare_for_use()
    return t


def to_PLY(tissue, file_name):
    """
    Saves the tissue to a PLY file
    """
    with open(file_name, 'w') as ply_file:
        print ('Saving tissue to PLY file \'' + file_name + '\'')

        # Used as buffer to collect the contents of the PLY file
        ply = []

        # Compose PLY header
        ply.append('ply\n')
        ply.append('format ascii 1.0\n')
        ply.append('comment Generated by PyPTS.plytools\n')
        ply.append('comment https://pypi.python.org/pypi/PyPTS/\n')
        if tissue.num_nodes is not 0:
            ply.append('element vertex ' + str(tissue.num_nodes) + '\n')
            ply.append('property float x\n')
            ply.append('property float y\n')
            ply.append('property float z\n')
            # TODO: node attributes as properties

        if tissue.num_cells is not 0:
            # Necessary header info for cells and their nodes
            ply.append('element face ' + str(tissue.num_cells) + '\n')
            ply.append('property list uchar int vertex_index\n')

            # Header info for optional cell attributes
            for attr_name, attr_vals in tissue.cells_attributes.iteritems():
                # Look at kind of dtype to cover precision differences
                if attr_vals.dtype.kind == 'i':
                    # Some kind of integer property
                    ply.append('property int ' + attr_name + '\n')
                elif attr_vals.dtype.kind == 'f':
                    # Some kind of float property
                    ply.append('property float ' + attr_name + '\n')
                else:
                    # I don't know what to do with this one
                    print('Cell attribute \'' + attr_name + '\' of type \'' \
                          + attr_vals.dtype.name + \
                          '\' not supported for PLY output; will be ignored.')

        ply.append('end_header\n')

        # Compose PLY data: NODES
        for n_idx in tissue.nodes_idx:
            ply.append(str(tissue.nodes_xy[n_idx, 0]) + ' ' + \
                       str(tissue.nodes_xy[n_idx, 1]) + ' 0.0\n')
            # TODO: node attributes as properties

        # Compose PLY data: CELLS
        for c_idx in tissue.cells_idx:
            # First int is the number of nodes to come
            ply.append(str(tissue.cells_num_nodes[c_idx]))
            # Following ints are the index values of nodes
            for cn_id in tissue.cells_nodes[c_idx]:
                ply.append(' ' + str(cn_id))

            # Cell attribute values
            for attr_name, attr_vals in tissue.cells_attributes.iteritems():
                # Look at kind of dtype to cover precision differences
                if attr_vals.dtype.kind in ['i', 'f']:
                    # Some kind of integer / float property
                    ply.append(' ' + str(attr_vals[c_idx]))
                else:
                    # Ignore, a warning was already printed before
                    pass
            # Next cell
            ply.append('\n')

        # Dump buffer to file
        ply_file.writelines(ply)

