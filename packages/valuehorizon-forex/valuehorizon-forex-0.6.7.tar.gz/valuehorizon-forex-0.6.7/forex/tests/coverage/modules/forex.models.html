<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
    <title>Test coverage report: forex.models</title>
    <style type="text/css" media="screen">
      a
      {
        color: #3d707a;
      }
      
      a:hover, a:active
      {
        color: #bf7d18;
      }
    
      body 
      {
        font-family: "Lucida Sans Unicode", "Lucida Grande", sans-serif;
        font-size: 13px;
      }
      
      .nav 
      {
        font-size: 12px;
        margin-left: 50px;
      }

      .ignored
      {
        color: #707070;
      }

      .executed 
      {
        color: #3d9900;
      }

      .missed 
      {
        color: red;
        font-weight: bold;
      }

      .excluded 
      {
        color: #6090f0;
        font-weight: lighter;
      }
    
      #content-header 
      {
        font-size: 12px;
        padding: 18px 0 18px 50px;
      }

      #content-header h1 
      {
        font-size: 16px;
        margin: 10px 0 0 0;
        color: #909090;
      }
      
      #module-name
      {
        color: #583707;
      }
    
      #content-header p
      {
        font-size: 13px;
        margin: 0;
        color: #909090;
      }

      #content-header .normal 
      {
        color: #609030;
      }

      #content-header .warning 
      {
        color: #d0a000;
      }

      #content-header .critical 
      {
        color: red;
      }
      
      #source-listing 
      {
        margin-bottom: 24px;
      }

      #source-listing ol 
      {
        padding: 0 0 0 50px;
        width: 90%;
        font-family: monospace;
        list-style-position: outside;
      }

      #source-listing ol li 
      {
        line-height: 18px;
        font-size: small;
      }
        
      #source-listing ol code 
      {
        padding:  0 .001em 0 0; /* Firefox doesn't render empty li's properly */
        font-size: medium;
        white-space: pre;
      }
   </style>
  </head>

  <body>

<div class="nav">
  <a href="forex.__init__.html">forex.__init__</a> &lt;&lt;
  <a href="../index.html">index</a>
</div>

<div id="content-header">
  <h1>
    <span id="module-name">forex.models</span>:
    140 total statements,
    <span class="normal">93.0% covered</span>
  </h1>
  <p>Generated: Thu 2016-02-04 14:24 AST</p>
  <p>Source file: /home/kevin/Development/custom apps/valuehorizon-forex/forex/models.py</p>
  <p>
    Stats:
    <span class="executed">120 executed</span>,
    <span class="missed">9 missed</span>,
    <span class="excluded">11 excluded</span>,
    <span class="ignored">114 ignored</span> 
  </p> 
</div>

<div id="source-listing">
  <ol>
    <li class="excluded"><code>from django.db import models</code></li>
<li class="excluded"><code>from django.db.models import Manager</code></li>
<li class="excluded"><code>from django.core.validators import MinValueValidator, ValidationError</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code># Import misc packages</code></li>
<li class="excluded"><code>import numpy as np</code></li>
<li class="excluded"><code>from datetime import date, timedelta</code></li>
<li class="excluded"><code>from decimal import Decimal</code></li>
<li class="excluded"><code>from pandas import DataFrame, date_range</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>PRICE_PRECISION = 4</code></li>
<li class="executed"><code>DATEFRAME_START_DATE = date(2005,1,1)</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>class Currency(models.Model):</code></li>
<li class="ignored"><code>    """</code></li>
<li class="ignored"><code>    Represents a currency according to ISO 4217 standards.</code></li>
<li class="ignored"><code>    """</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    name = models.CharField(max_length=255)</code></li>
<li class="executed"><code>    symbol = models.CharField(max_length=10, unique=True)</code></li>
<li class="executed"><code>    ascii_symbol = models.CharField(max_length=20, null=True, blank=True)</code></li>
<li class="executed"><code>    num_code = models.IntegerField(null=True, blank=True)</code></li>
<li class="executed"><code>    digits = models.IntegerField(null=True, blank=True)  # Digits after decimal (minor unit)</code></li>
<li class="executed"><code>    description = models.TextField(blank=True)</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>    # Cached Data</code></li>
<li class="executed"><code>    date_modified = models.DateTimeField(null=True, blank=True, editable=False, auto_now=True)</code></li>
<li class="executed"><code>    date_created = models.DateTimeField(null=True, blank=True, editable=False, auto_now_add=True)</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    class Meta:</code></li>
<li class="executed"><code>        verbose_name_plural = 'Currencies'</code></li>
<li class="executed"><code>        verbose_name = 'Currency'</code></li>
<li class="executed"><code>        ordering = ['name', 'symbol']</code></li>
<li class="ignored"><code></code></li>
<li class="excluded"><code>    def __unicode__(self):</code></li>
<li class="excluded"><code>        return u'%s, %s' % (unicode(self.name), unicode(self.symbol))</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    def get_verbose_name(self):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Fetch verbose name from _meta. This is useful if we want to do haystack</code></li>
<li class="ignored"><code>        faceting on the model's objects.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        return self._meta.verbose_name</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    def get_verbose_name_plural(self):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Fetch plural verbose name from _meta. This is useful if we want to do haystack</code></li>
<li class="ignored"><code>        faceting on the model's objects.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        return self._meta.verbose_name_plural</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    def generate_dataframe(self, start_date=None, end_date=None):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        """</code></li>
<li class="executed"><code>        first_series_point = CurrencyPrice.objects.filter(currency=self)[0]</code></li>
<li class="executed"><code>        last_series_point = CurrencyPrice.objects.filter(currency=self).reverse()[0]</code></li>
<li class="executed"><code>        start_date = first_series_point.date if start_date == None else max(first_series_point.date, start_date)</code></li>
<li class="executed"><code>        temp_start_date = start_date - timedelta(days=3) # Add lag</code></li>
<li class="executed"><code>        end_date = last_series_point.date if end_date == None else min(last_series_point.date, end_date)</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>        currency_date = CurrencyPrice.objects.filter(currency=self, date__gte=temp_start_date, date__lte=end_date).values_list('date', 'ask_price', 'bid_price')</code></li>
<li class="executed"><code>        currency_data_array = np.core.records.fromrecords(currency_date, names=['DATE', "ASK", "BID"])</code></li>
<li class="executed"><code>        df = DataFrame.from_records(currency_data_array, index='DATE').astype(float)</code></li>
<li class="executed"><code>        df['MID'] = (df['ASK'] + df['BID']) / 2.0</code></li>
<li class="executed"><code>        df['CHANGE'] = df['MID'].pct_change()</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>        required_dates = date_range(start_date,end_date)</code></li>
<li class="executed"><code>        df = df.reindex(required_dates)</code></li>
<li class="executed"><code>        df = df.fillna(method='ffill')</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>        return df</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>class CurrencyPriceManager(Manager):</code></li>
<li class="ignored"><code>    """ Adds some added functionality """</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    def generate_dataframe(self, symbols=None, date_index=None, price_type="mid"):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Generate a dataframe consisting of the currency prices (specified by symbols)</code></li>
<li class="ignored"><code>        from the start to end date</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # Set defaults if necessary</code></li>
<li class="executed"><code>        if symbols == None:</code></li>
<li class="executed"><code>            symbols = list(Currency.objects.all().values_list('symbol', flat=True))</code></li>
<li class="executed"><code>        try:</code></li>
<li class="executed"><code>            start_date = date_index[0]</code></li>
<li class="executed"><code>            end_date = date_index[-1]</code></li>
<li class="executed"><code>        except:</code></li>
<li class="executed"><code>            start_date = DATEFRAME_START_DATE</code></li>
<li class="executed"><code>            end_date = date.today()</code></li>
<li class="executed"><code>        date_index = date_range(start_date, end_date)</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>        currency_price_data = CurrencyPrice.objects.filter(currency__symbol__in=symbols,</code></li>
<li class="ignored"><code>                                                            date__gte=date_index[0],</code></li>
<li class="ignored"><code>                                                            date__lte=date_index[-1]).values_list('date', 'currency__symbol', 'ask_price', 'bid_price')</code></li>
<li class="executed"><code>        try:</code></li>
<li class="executed"><code>            forex_data_array = np.core.records.fromrecords(currency_price_data, names=['date', 'symbol', 'ask_price', 'bid_price'])</code></li>
<li class="executed"><code>        except IndexError:</code></li>
<li class="executed"><code>            forex_data_array = np.core.records.fromrecords([(date(1900,1,1) , "", 0, 0)], names=['date', 'symbol', 'ask_price', 'bid_price'])</code></li>
<li class="executed"><code>        df = DataFrame.from_records(forex_data_array, index='date')</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>        df['date'] = df.index</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>        if price_type == "mid":</code></li>
<li class="executed"><code>            df['price'] = (df['ask_price'] + df['bid_price']) / 2</code></li>
<li class="missed"><code>        elif price_type == "ask_price":</code></li>
<li class="missed"><code>            df['price'] = df['ask_price']</code></li>
<li class="missed"><code>        elif price_type == "bid_price":</code></li>
<li class="missed"><code>            df['price'] = df['bid_price']</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="missed"><code>            raise ValueError("price_type must be on of 'ask', 'bid' or 'mid'")</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>        df = df.pivot(index='date', columns='symbol', values='price')</code></li>
<li class="executed"><code>        df = df.reindex(date_index)</code></li>
<li class="executed"><code>        df = df.fillna(method="ffill")</code></li>
<li class="executed"><code>        unlisted_symbols = list(set(symbols) - set(df.columns))</code></li>
<li class="executed"><code>        for unlisted_symbol in unlisted_symbols:</code></li>
<li class="executed"><code>            df[unlisted_symbol] = np.nan</code></li>
<li class="executed"><code>        df = df[symbols]</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>        return df</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>class CurrencyPrice(models.Model):</code></li>
<li class="ignored"><code>    """</code></li>
<li class="ignored"><code>    Represents a currency price to US</code></li>
<li class="ignored"><code>    """</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    currency = models.ForeignKey(Currency)</code></li>
<li class="executed"><code>    date = models.DateField()</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>    # Price Data per $1 of US</code></li>
<li class="executed"><code>    ask_price = models.DecimalField(max_digits=20, decimal_places=PRICE_PRECISION,</code></li>
<li class="ignored"><code>                                    validators=[MinValueValidator(Decimal('0.00'))])</code></li>
<li class="executed"><code>    bid_price = models.DecimalField(max_digits=20, decimal_places=PRICE_PRECISION,</code></li>
<li class="ignored"><code>                                    validators=[MinValueValidator(Decimal('0.00'))])</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>    # Cached Data</code></li>
<li class="executed"><code>    date_modified = models.DateTimeField(null=True, blank=True, editable=False, auto_now=True)</code></li>
<li class="executed"><code>    date_created = models.DateTimeField(null=True, blank=True, editable=False, auto_now_add=True)</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>    # Add custom managers</code></li>
<li class="executed"><code>    objects=CurrencyPriceManager()</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    class Meta:</code></li>
<li class="executed"><code>        verbose_name_plural = 'Currency Prices'</code></li>
<li class="executed"><code>        verbose_name = 'Currency Price'</code></li>
<li class="executed"><code>        ordering = ['date', ]</code></li>
<li class="executed"><code>        unique_together=['date', 'currency']</code></li>
<li class="executed"><code>        get_latest_by = "date"</code></li>
<li class="ignored"><code></code></li>
<li class="excluded"><code>    def __unicode__(self):</code></li>
<li class="excluded"><code>        return u'%s, %s' % (unicode(self.currency),</code></li>
<li class="ignored"><code>                            unicode(self.date),)</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    def save(self, *args, **kwargs):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Sanitation checks</code></li>
<li class="ignored"><code>        """</code></li>
<li class="executed"><code>        if self.ask_price &lt; 0:</code></li>
<li class="executed"><code>            raise ValidationError("Ask price must be greater than zero")</code></li>
<li class="executed"><code>        if self.bid_price &lt; 0:</code></li>
<li class="executed"><code>            raise ValidationError("Bid price must be greater than zero")</code></li>
<li class="executed"><code>        if self.ask_price &lt; self.bid_price:</code></li>
<li class="executed"><code>            raise ValidationError("Ask price must be at least Bid price")</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>        super(CurrencyPrice, self).save(*args, **kwargs) # Call the "real" save() method.</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    @property</code></li>
<li class="ignored"><code>    def mid_price(self):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Compute the mid point between the bid and ask prices</code></li>
<li class="ignored"><code>        """</code></li>
<li class="executed"><code>        return (self.ask_price + self.bid_price) / Decimal('2.0')</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    @property</code></li>
<li class="ignored"><code>    def spread(self):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Compute the difference between bid and ask prices</code></li>
<li class="ignored"><code>        """</code></li>
<li class="executed"><code>        return (self.ask_price - self.bid_price)</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    @property</code></li>
<li class="ignored"><code>    def ask_price_us(self):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Calculate the ask_price in USD. This is the inverse</code></li>
<li class="ignored"><code>        of the ask price.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="executed"><code>        if self.ask_price != 0:</code></li>
<li class="executed"><code>            return 1 / Decimal(str(self.ask_price))</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="executed"><code>            raise ZeroDivisionError('Ask price is zero')</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    @property</code></li>
<li class="ignored"><code>    def bid_price_us(self):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Calculate the bid_price in USD. This is the inverse</code></li>
<li class="ignored"><code>        of the bid price.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="executed"><code>        if self.bid_price != 0:</code></li>
<li class="executed"><code>            return 1 / Decimal(str(self.bid_price))</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="executed"><code>            raise ZeroDivisionError('Bid price is zero')</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>def conversion_factor(from_symbol, to_symbol, date):</code></li>
<li class="ignored"><code>    """</code></li>
<li class="ignored"><code>    Generates a multiplying factor used to convert tow currencies</code></li>
<li class="ignored"><code>    """</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    if from_symbol == to_symbol:</code></li>
<li class="missed"><code>        return Decimal('1.0')</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    from_currency = Currency.objects.get(symbol=from_symbol)</code></li>
<li class="executed"><code>    try:</code></li>
<li class="executed"><code>        from_currency_price = CurrencyPrice.objects.get(currency=from_currency, date=date).mid_price</code></li>
<li class="executed"><code>    except CurrencyPrice.DoesNotExist:</code></li>
<li class="executed"><code>        print "Cannot fetch prices for %s on %s" % (str(from_currency), str(date))</code></li>
<li class="executed"><code>        return None</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    to_currency = Currency.objects.get(symbol=to_symbol)</code></li>
<li class="executed"><code>    try:</code></li>
<li class="executed"><code>        to_currency_price = CurrencyPrice.objects.get(currency=to_currency, date=date).mid_price</code></li>
<li class="executed"><code>    except CurrencyPrice.DoesNotExist:</code></li>
<li class="executed"><code>        print "Cannot fetch prices for %s on %s" % (str(to_currency), str(date))</code></li>
<li class="executed"><code>        return None</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    return to_currency_price / from_currency_price</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>def convert_currency(from_symbol, to_symbol, value, date):</code></li>
<li class="ignored"><code>    """</code></li>
<li class="ignored"><code>    Converts an amount of money from one currency to another on a specified date.</code></li>
<li class="ignored"><code>    """</code></li>
<li class="executed"><code>    if from_symbol == to_symbol:</code></li>
<li class="executed"><code>        return value</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    factor = conversion_factor(from_symbol, to_symbol, date)</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    if type(value) == float:</code></li>
<li class="executed"><code>        output = value * float(factor)</code></li>
<li class="executed"><code>    elif type(value) == Decimal:</code></li>
<li class="executed"><code>        output = Decimal(format(value * factor, '.%sf' % str(PRICE_PRECISION)))</code></li>
<li class="executed"><code>    elif type(value) in [np.float16, np.float32, np.float64, np.float128, np.float]:</code></li>
<li class="missed"><code>        output = float(value) * float(factor)</code></li>
<li class="ignored"><code>    else:</code></li>
<li class="executed"><code>        output = None</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    return output</code></li>
<li class="ignored"><code></code></li>
  </ol>
</div>

<div class="nav">
  <a href="forex.__init__.html">forex.__init__</a> &lt;&lt;
  <a href="../index.html">index</a>
</div>

  </body>
</html>

