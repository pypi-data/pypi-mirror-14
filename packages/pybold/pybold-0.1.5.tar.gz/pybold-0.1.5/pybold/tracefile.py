'''
:author: Iyad Kandalaft <iyad.kandalaft@canada.ca>
:organization: Agriculture and Agri-Foods Canada
:group: Microbial Biodiversity Bioinformatics
:contact: mbb@agr.gc.ca 
:license: LGPL v3
'''
import StringIO
import os.path
import tarfile

from pybold import Endpoint, PUBLIC_API_URL
import pybold.sequence
import pybold.specimen


class Tracefile(object):
    '''Convenience class to deal with Tracefiles from BOLD API'''
    
    @staticmethod
    def parse_from_tar(file_name=None, tar_string=None):
        '''Parses tracefiles from the tar archive generated by the BOLD trace public API
        :param file_name: Path to tar file to read
        :param tar_string: tar file to read from a string
        :raise tarfile.ReadError: If the BOLD API return an invalid tarfile
        :raise ValueError:  If neither the file_name and the tar_string args are provided
        :raise ValueError: If the Process ID in the TRACE_FILE_INFO.txt does not match a file name inside the tar archive
        :return: return Returns a list of Tracefile objects
        '''
        if tar_string is not None:
            fileobj = StringIO.StringIO(tar_string)
        else:
            fileobj = None

        chromat_tar = tarfile.open(name=file_name, mode='r:', fileobj=fileobj)
        
        # Build a dictionary containing the process_id, taxon, marker, genbank_accession, and filename 
        # based on the content of the TRACE_FILE_INFO.txt within the tar archive
        fileobj = chromat_tar.extractfile('TRACE_FILE_INFO.txt')
        tracefiles_d = {}
        for row in fileobj.readlines():
            row_traceinfo = row.rstrip().split("\t")
            if len(row_traceinfo) != 5:
                continue
            tracefiles_d[row_traceinfo[0]] = {'process_id': row_traceinfo[0],
                                             'taxon': row_traceinfo[1],
                                             'marker': row_traceinfo[2],
                                             'genbank_accession': row_traceinfo[3],
                                             'tracefile': row_traceinfo[4] 
                                             }
        
        tracefile_list = [];
        
        for member in chromat_tar.getmembers():
            if not member.isfile() or member.name == 'TRACE_FILE_INFO.txt':
                continue
            
            fileobj = chromat_tar.extractfile(member)
            
            for process_id in tracefiles_d.keys():
                if process_id not in member.name:
                    continue
                
                # Exit the loop because we found the process id in the tracefile name
                break
            
            if not process_id:
                raise ValueError()
            
            tracefile_list.append(Tracefile(process_id,
                                                fileobj, 
                                                tracefiles_d[process_id]['marker'], 
                                                tracefiles_d[process_id]['taxon'], 
                                                tracefiles_d[process_id]['genbank_accession'],
                                                member.name
                                                )
                                       )
            
        #chromat_tar.close()
        
        return tracefile_list

    def __init__(self, process_id, fileobj, marker, taxon, genbank_accession, filename):
        '''Initializes Tracefile object
        Populates the attributes based on provided parameters.  It is recommended to use the class method parse_from_tar to
        obtain tracefile objects. 
        :param process_id: BOLD Process ID associated with the Tracefile
        :param fileobj: A file-like object of the Tracefile
        :param marker: Barcode marker based on BOLD naming convention
        '''
        self.specimen = None
        self.sequence = None
        
        self.fileobj = fileobj
        self.process_id = process_id
        self.marker = marker
        self.taxon = taxon
        self.genbank_accession = genbank_accession
        self.filename = filename

        super(Tracefile, self).__init__()

    @property
    def format(self):
        '''Parse the format of the file based on the extension'''
        #TODO improve detection of tracefile format
        return os.path.splitext(self.filename)[1].lstrip('.')

    @property
    def specimen(self):
        '''Lookup and return the Specimen object associated this tracefile based on the process ID.'''
        if self.__specimen is None:
            self.specimen = pybold.specimen.SpecimensClient().get(ids=self.process_id).pop()
             
        return self.__specimen
    
    @specimen.setter
    def specimen(self, specimen_obj):
        self.__specimen = specimen_obj

    @property
    def sequence(self):
        '''Lookup and return the Sequence object associated with this tracefile based on the process ID.''' 
        # If property is not set, then call the setter
        if self.__sequence is None:
            # Provide the setter with a Sequence object using an API query that fetches the sequence
            self.sequence = pybold.sequence.SequencesClient().get(ids=self.process_id).pop()
        
        return self.__sequence
    
    @sequence.setter
    def sequence(self, sequence_obj):        
        self.__sequence =  sequence_obj

    def to_file(self, dir_path=None, filename=None): 
        '''Writes tracefile to disk
        @raise IOError: when writing the tracefile 
        @return: Path to the trace file written to disk
        '''
        if dir_path is None:
            dir_path = os.path.curdir
        
        if not os.path.exists(dir_path):
            os.makedirs(dir_path, 0755)
            
        if filename is None:
            filename = self.filename
        
        full_path = os.path.join(dir_path, filename)
        with open(full_path, 'w+') as fh:
            original_pos = self.fileobj.tell()
            self.fileobj.seek(0)
            fh.write(self.fileobj.read())
            self.fileobj.seek(original_pos)
            return full_path
    
class TracefilesClient(Endpoint):
    '''WebServices consumer for the Tracefiles end-point that fetches Tracefiles based on provided criteria and returns Tracefiles objects.'''
    ENDPOINT_NAME = 'trace'
    
    def __init__(self, base_url=PUBLIC_API_URL):
        '''Initialize the object
        :param base_url: Override the end-point URL
        '''
        self.base_url = base_url
        self.tracefile_list = []
        super(TracefilesClient, self).__init__()
    
    def get(self, taxon=None, ids=None, bins=None, containers=None, institutions=None, researchers=None, geo=None, marker=None, timeout=5):
        '''Fetch tracefiles that match the provided criteria and assign it to self.tracefile_list and return the list'''
        result = super(TracefilesClient, self).get({
                                    'taxon': taxon, 
                                    'ids': ids, 
                                    'bin': bins, 
                                    'container': containers, 
                                    'institutions': institutions, 
                                    'researchers': researchers, 
                                    'geo': geo,
                                    'marker': marker }, timeout=timeout)

        self.tracefile_list = Tracefile.parse_from_tar(tar_string=result)
        
        return self.tracefile_list

    def get_process_ids(self):
        '''Return a list of process IDs for the fetched tracefiles'''
        ids = []
        for tracefile in self.tracefile_list:
            ids.append(tracefile.process_id)
        
        return ids

    def get_sequences(self):
        '''Lookup and return Sequence objects for the fetched tracefiles based on the process IDs''' 
        ids_query = '|'.join(self.get_process_ids())
        return pybold.sequence.SequencesClient(self.base_url).get(ids=ids_query)
        
    def get_specimens(self):
        '''Lookup and return Specimen objects for the fetched tracefiles based on the process IDs'''
        ids_query = '|'.join(self.get_process_ids())
        return pybold.specimen.SpecimensClient(self.base_url).get(ids=ids_query)

if __name__ == "__main__":
    pass
    