Formula  : (P(b) until D(b))
Formula C  : Until(Predicate('P', [Constant('b')]),Predicate('D', [Constant('b')]))
Trace    : {P(c)};{P(c)};{P(b)}
Result Progression: ? after 3 events.
LTLFO
Formula : (P('b') U D('b'))
Trace   : {P('c')},{P('c')},{P('b')}
Result Progression: ⊥ after 1 events.

-> Fixed

Formula  : (future(D(a)) and future(P(a)))
Formula C  : And(Future(Predicate('D', [Constant('a')])),Future(Predicate('P', [Constant('a')])))
Trace    : {D(a)};{P(a)};{D(a)}
-> fixed


Formula  : (next((not((D(c) and D(b))) or ((D(c) and P(a)) release future(P(c))))) or P(c))
Formula C  : Or(Next(Or(Neg(And(Predicate('D', [Constant('c')]),Predicate('D', [Constant('b')]))),Release(And(Predicate('D', [Constant('c')]),Predicate('P', [Constant('a')])),Future(Predicate('P', [Constant('c')]))))),Predicate('P', [Constant('c')]))
Trace    : {D(a)};{D(b)};{D(a)}
(not((D(c) and D(b))) or ((D(c) and P(a)) release future(P(c))))
(not((D(c) and D(b))) or ((D(c) and P(a)) release future(P(c))))
(not((D(c) and D(b))) or ((D(c) and P(a)) release future(P(c))))
Result Progression: ? after 3 events.
LTLFO
Formula : ((X ((~ (D('c') /\ D('b'))) \/ ((D('c') /\ P('a')) W (F P('c'))))) \/ P('c'))
Trace   : {D('a')},{D('b')},{D('a')}
Result Progression: ⊤ after 2 events.


Formula  : not((P(a) until (not(P(a)) release not(always(P(a))))))
Formula C  : Neg(Until(Predicate('P', [Constant('a')]),Release(Neg(Predicate('P', [Constant('a')])),Neg(Always(Predicate('P', [Constant('a')]))))))
Trace    : {P(a)};{P(a)};{P(b)}
Result Progression: ? after 3 events.
LTLFO
Formula : (~ (P('a') U ((~ P('a')) W (~ (G P('a'))))))
Trace   : {P('a')},{P('a')},{P('b')}
Result Progression: ⊥ after 3 events.


============ LTLMON :
Formula  : (next(future(next(next(P(a))))) and P(c))
Formula C  : And(Next(Future(Next(Next(Predicate('P', [Constant('a')]))))),Predicate('P', [Constant('c')]))
Trace    : {P(b)};{P(b)};{P(b)}
Result Progression: ? after 3 events.

============ LTLFO2MON :
Formula : ((X (F (X (X P('a'))))) /\ P('c'))
Trace   : {P('b')},{P('b')},{P('b')}
Result Progression: ⊥ after 1 events.

============ LTLMON :
Formula   : (not(always(next((P(b) or P(b))))) or next(P(b)))
Formula C : Or(Neg(Always(Next(Or(Predicate('P', [Constant('b')]),Predicate('P', [Constant('b')]))))),Next(Predicate('P', [Constant('b')])))
Trace     : {P(a)};{P(a)};{P(b)}
Result Progression: ? after 3 events.

============ LTLFO2MON :
Formula : ((~ (G (X (P('b') \/ P('b'))))) \/ (X P('b')))
Trace   : {P('a')},{P('a')},{P('b')}
Result Progression: ⊤ after 2 events.

Result Progression: ? after 3 events.
Result Progression: ⊤ after 2 events.


============ LTLMON :
Formula   : always(((next(P(c)) or next(future(P(a)))) and P(a)))
Formula C : Always(And(Or(Next(Predicate('P', [Constant('c')])),Next(Future(Predicate('P', [Constant('a')])))),Predicate('P', [Constant('a')])))
Trace     : {P(a)};{P(c)};{P(a)}
(P(c) and future(P(a)))
(true and (false or F(P(a))))
true
Result Progression: ⊤ after 3 events.

============ LTLFO2MON :
Formula : (G (((X P('c')) \/ (X (F P('a')))) /\ P('a')))
Trace   : {P('a')},{P('c')},{P('a')}
Result Progression: ⊥ after 2 events.

## Result are different !
Result Progression: ⊤ after 3 events.
Result Progression: ⊥ after 2 events.
Debug y/n : y
(P(c) and future(P(a)))
(true and (false or F(P(a))))
true
Result Progression: ⊤ after 3 events.


============ LTLMON :
Formula   : always(future(next(P(c))))
Formula C : Always(Future(Next(Predicate('P', [Constant('c')]))))
Trace     : {P(a)};{P(b)};{P(b)}
((P(c) or F(next(P(c)))) and G(future(next(P(c)))))
((false or (P(c) or F(next(P(c))))) and ((P(c) or F(next(P(c)))) and G(future(next(P(c))))))
Result Progression: ⊥ after 2 events.
(P(c) and F(next(P(c))))
false
Result Progression: ⊥ after 2 events.

============ LTLFO2MON :
Formula : (G (F (X P('c'))))
Trace   : {P('a')},{P('b')},{P('b')}
Result Progression: ? after 3 events.

## Result are different !
Result Progression: ⊥ after 2 events.
Result Progression: ⊥ after 2 events.
Result Progression: ? after 3 events.
Debug y/n : y
(P(c) and F(next(P(c))))
false
Result Progression: ⊥ after 2 events.

============ LTLMON :
Formula   : ((P(a) until P(b)) until always(P(c)))
Formula C : Until(Until(Predicate('P', [Constant('a')]),Predicate('P', [Constant('b')])),Always(Predicate('P', [Constant('c')])))
Trace     : {P(b)};{P(a)};{P(a)};{P(a)};{P(c)}
Result Progression: ? after 5 events.
============ LTLFO2MON :
Formula : ((P('a') U P('b')) U (G P('c')))
Trace   : {P('b')},{P('a')},{P('a')},{P('a')},{P('c')}
Result Progression: ⊥ after 5 events.
## Result are different !
Result Progression: ? after 5 events.
Result Progression: ⊥ after 5 events.