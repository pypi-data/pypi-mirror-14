from distutils.core import setup

setup(
    name='timezonefinder',
    version='1.003',
    packages=['timezonefinder'],
    package_data={'timezonefinder': ['timezone_data.bin']},
    description='Python library to look up timezone from lat / long offline. Improved version of "pytzwhere".',
    author='J. Michelfeit',
    author_email='python@michelfe.it',
    license='MIT licence',
    url='https://github.com/MrMinimal64/timezonefinder',  # use the URL to the github repo
    download_url='https://github.com/MrMinimal64/timezonefinder/tarball/1.0',
    classifiers=[
        'Intended Audience :: Developers',
        'License :: OSI Approved :: MIT License',
        'Operating System :: OS Independent',
        'Programming Language :: Python',
        'Programming Language :: Python :: 2',
        'Programming Language :: Python :: 3',
        'Topic :: Software Development :: Localization',
    ],
    long_description="This is a fast and lightweight python project to lookup the\ncorresponding timezone for any given lat/lng on earth entirely offline.\n\nThis project is derived from and has been successfully tested against\n`pytzwhere <https://pypi.python.org/pypi/tzwhere/2.2>`__\n(`github <https://github.com/pegler/pytzwhere>`__).\n\nThe underlying timezone data is based on work done by `Eric\nMuller <http://efele.net/maps/tz/world/>`__.\n\nIt is also similar to\n`django-geo-timezones <https://pypi.python.org/pypi/django-geo-timezones/0.1.2>`__\n\nDependencies\n============\n\n(``python``, ``math``, ``struct``, ``os``)\n\n``numpy``\n\nmaybe also ``numba`` and its Requirements\n\nThis is only for precompiling the time critical algorithms. If you want\nto use this, just uncomment all the ``@jit(...)`` annotations and the\n``import ...`` line in ``timezonefinder.py``. When you only look up a\nfew points once in a while, the compilation time is probably outweighing\nthe benefits. When using ``certain_timezone_at()`` and especially\n``closest_timeyone_at()`` however, I highly recommend using ``numba``\n(see speed comparison below)! The amount of shortcuts used in the\n``.bin`` are also only optimized for the use with ``numba``.\n\nInstallation\n============\n\ninstall the dependencies (see above):\n\n::\n\n    pip install numpy\n    #...\n\nthen simply:\n\n::\n\n    pip install timezonefinder\n\n(or just download ``timezonefinder.py`` and ``timezone_data.bin`` and\nput them in the directory you want to use them from.)\n\nUsage\n=====\n\n::\n\n    from timezonefinder.timezonefinder import TimezoneFinder\n\n    tf = TimezoneFinder()\n\nBasic usage (fast algorithm):\n\n::\n\n    #point = (longitude, latitude)\n    point = (13.358, 52.5061)\n    print( tf.timezone_at(*point) )\n    # = Europe/Berlin\n\nTo make sure a point is really inside a timezone (slower):\n\n::\n\n    print( tf.certain_timezone_at(*point) )\n    # = Europe/Berlin\n\nTo find the closest timezone (slow):\n\n::\n\n    #only use this when the point is not inside a polygon!\n    #this only checks the polygons in the surrounding shortcuts (not all polygons)\n\n    point = (12.773955, 55.578595)\n    print( tf.closest_timezone_at(*point) )\n    # = Europe/Copenhagens\n\nTo increase search radius even more (very slow, use ``numba``!):\n\n::\n\n    # this checks all the polygons within +-3 degree lng and lat \n    # keep in mind that x degrees lat are not the same distance apart than x degree lng!\n    print( tf.closest_timezone_at(lng=point[0],lat=point[1],delta_degree=3) )\n    # = Europe/Copenhagens\n\nTo maximize the chances of getting a result in a ``Django`` application\nit might look like:\n\n::\n\n    def find_timezone(request, lat, lng):\n        \n        lat = float(lat)\n        lng = float(lng)\n        timezone_name = tf.timezone_at(lng, lat)\n        if timezone_name is None:\n            timezone_name = tf.closest_timezone_at(lng, lat)\n            # maybe even increase the search radius when it is still None\n        \n        # ... do something with timezone_name ...\n\nComparison to pytzwhere\n=======================\n\nIn comparison to\n`pytzwhere <https://pypi.python.org/pypi/tzwhere/2.2>`__ I managed to\n**speed up** the queries **by more than 100 times**. **Initialisation\ntime** and **memory usage** are also **significanlty reduced**, while my\nalgorithm yields the **same results**. In some cases ``pytzwhere`` even\ndoes not find anything and ``timezonefinder`` does, for example when the\npoint is only close to a timezone.\n\nSimilarities:\n-------------\n\n-  results\n\n-  data being used\n\nDifferences:\n------------\n\n-  the data is now stored in a memory friendly 35MB ``.bin`` and needed\n   data is directly being read on the fly (instead of reading and\n   converting the 76MB ``.csv`` (mostly floats stored as strings!) into\n   memory every time a class is created).\n\n-  precomputed shortcuts are stored in the ``.bin`` to quickly look up\n   which polygons have to be checked (instead of creating them on every\n   startup)\n\n-  optimized algorithms\n\n-  introduced proximity algorithm (still experimental)\n\n-  use of ``numba`` for speeding things up much further.\n\nExcerpt from my **test results**\ \*:\n\n::\n\n      testing 1000 realistic points\n      MISMATCHES**: \n      /\n      testing 10000 random points\n      MISMATCHES**:\n      /\n      in 11000 tries 0 mismatches were made\n      fail percentage is: 0.0\n      \n      \n      TIMES for 1000 realistic queries***:\n      pytzwhere:  0:00:18.184299\n      timezonefinder:  0:00:00.126715\n      143.51 times faster\n      \n      TIMES for  10000 random queries****:\n      pytzwhere: 0:01:36.431927\n      timezonefinder: 0:00:00.626145\n      154.01 times faster\n      \n      Startup times:\n      pytzwhere: 0:00:09.531322\n      timezonefinder: 0:00:00.000361\n      26402.55 times faster\n\n\*timezone\_at() with ``numba`` active\n\n\*\*mismatch: pytzwhere finds something and then timezonefinder finds\nsomething else\n\n\*\*\*realistic queries: just points within a timezone (= pytzwhere\nyields result)\n\n\*\*\*\*random queries: random points on earth\n\nSpeed Impact of Numba\n=====================\n\n::\n\n    TIMES for 1000 realistic queries***:\n\n    timezone_at():\n    wo/ numa: 0:00:01.017575\n    w/ numa: 0:00:00.289854\n    3.51 times faster\n\n    certain_timezone_at():\n    wo/ numa:   0:00:05.445209\n    w/ numa: 0:00:00.290441\n    14.92 times faster\n\n    closest_timezone_at():\n    (delta_degree=1)\n    wo/ numa: 0:02:32.666238\n    w/ numa: 0:00:02.688353\n    40.2 times faster\n\n(this is not inlcuded in my tests)\n\nContact\n=======\n\nif you encounter any bugs, have suggestions, criticism etc. feel free to\n**open an Issue** on Git or contact me: **python[at]michelfe.it**\n\nLicense\n=======\n\n``timezonefinder`` is distributed under the terms of the MIT license\n(see LICENSE.txt).\n",
)

