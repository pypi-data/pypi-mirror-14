
MAINTAIN (make sure this stuff is always perfected)

    Keep __all__ up to date with all the useful functions

    Comment and properly docstring everything

    Keep the -h follow all the other common -h practices

    Make sure that the -h is up to date, including all the version info of all the external features (gcc/Cython)

    Make sure that you constantly search for the assumptions cyther makes

    Make my getIncludeAndRuntime() function is up to date with build_ext in distutils

    Any name cool badges to add? Make sure you got all the recent and useful ones
    Use http://shields.io/ to generate non changing badges

    Make sure the test_cyther.py file is updated to include the latest features (test everything!)


EASY FIX (easy breazy lemon squeazy)

    How to deal with non-standard extensions that people might be using? Don't error, but just have it print that
    it is non standard, and work anyway? What about Regex?

    Reorder all the functions in cyther.py to actually make sense

    Make a __all__ in __init__, and what other things can we put there

    Split cyther.py into several other modules?


MEDIUM FIX (ok, its do-able)

    None

HARD FIX (shit)

    Get the operating system dependant flags that are passed to gcc by distutils and inject them when building the
    preset

    Make sure that the file order provided doesn't matter when compiling multiple files that may depend on one another


EASY NEW FEATURES (easy peasy and planned)

    Get the arguments of run(timer=True) to work properly

    Make CytherError traceback invisible. Make sure that the error doesn't look like cyther.cyther.CytherError...


HARD NEW FEATURES (yes, planned)

    Instead of the include option, have the system automatically detect the python {}.get_include() modules

    Have a scriptble system of talking to the core and passing in arguments. THIS WOULD BE GREAT!!

    Add cl to the options that are available for compilers

    Say the search for the directories necessary for the runtime compilation fails, and returns nothing. Then run the
    crawl algorithm over the whole DRIVE to find a lib file that matches the REGEX definition


LOW PRIORITY (probably will happen)

    An option to just build the C, or to just take the C and build only the extension
    How could cyther be used with distutils??

    Function to clean a directory of everything 'locally build' related, or move it to a cythercache
    A function to remove EVERYTHING cyther related

    Always back up the previous compile if there was one. Then if there is an error, don't overwrite it with anything,
    but instead, keep the backup version. Have the new compilation attempt be built in the __cythercache__ directory


BEFORE DEPLOY (for me)

    Make sure that the version specified makes sense (major.minor.patch)

    Make sure that the README reflects the new interface changes

    Make sure that the CHANGELOG is up to date and includes the current version change

    Delete the comments that are no longer needed. Any junk or temporary commented code should be extracted

    Write a test script that actually tests the whole deal. Have it run every scenario and then
    USE the actual extension that it makes


QUESTIONS (yeah, these happen)

    Where is the best spot to put the README and all the other files?

    Add more presets?? I need to do a brainstorming situation...

    Don't have args and file, have only one object with everything in it. Does this even make sense?

    Is it wise to take out the checking procedures with the getIncludeAndRuntime() function. Why are they necessary??

    Would it be possible to automatically send me their __cytherinfo__ variable?

    Will sift ever have to return multiple results for the lib directories??

    What about lines like this platform.platform().strip().lower().startswith('windows')??
    What do the platform names even look like? Is their structure reliable? Does it need to be?

    What about bcpp or cygwin??

    Should we even give the option to build locally in the same file?

    Do the commands to argparse need to be changed. Maybe give them better names, and give each a long name.

    Is it necessary to make sure that os.pardir will never be a problem??

    How about using tempfile for the building files??

    How about packaging cython with cyther? Is this even useful?

    What about packaging the libraries with cyther?? Are they cross platform? How to even get these libs?

    What is the difference between os.name and sys.platform and platform.platform?
    Why do some return operating systems, and some return processor architectures
