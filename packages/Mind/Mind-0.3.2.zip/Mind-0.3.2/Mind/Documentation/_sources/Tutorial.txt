Mind 0.3.2 Tutorial
=================================
.. note::
   This tutorial covers using each module one by one but it doesn't cover making game with entire library.

Mind.Knowledge
-----------------------------------------------------
Knowledge is part of Mind for saving data (with *.knw* extension)

.. note::

   This module currently isn't *very* useful (mostly because of bugs) but it might be soon.

For beginning import Knowledge:

>>> from Mind import Knowledge

Then initialize *basic class for saving data*:

>>> data = Knowledge.Knowledge("test")

Then try this few lines (these adds data to data class):

>>> data['player'] = 5
>>> data[25] = 8
>>> data[21.753] = 'exit'
>>> data["something"] = [1, "X", [12.3, "Y"], 3]
>>> data
21.753 : exit
player : 5
something : [1, 'X', [12.3, 'Y'], 3]
25 : 8
>>> data[25]
8

Now try to save data and load:

>>> data.save_data()
>>> data = Knowledge.load("test")
>>> data
something : [1, 'X', [12.32, 'Y'], 3]
25 : 8
21.793000000000006 : exit
player : 5

.. warning::

   Saving decimal numbers isn't very correct and maximum is 3 decimals!

.. seealso::
   Mind.Test.

Mind.Orientation
--------------------------------------------
Orientation is part of library for maps.

At begining:

>>> from Mind import Orientation

We could first create map:

>>> Map = Orientation.MAP(1000, 1000)

Then we could add few points:

>>> A = Orientation.point(100, 100, Map, "A")
>>> B = Orientation.point(200, 200, Map, "B")
>>> C = Orientation.point(300, 200, Map, "C")

.. Note::
   If point is placed out of Map (here 1000 *width* and 1000 *height*) it will cause **MapError**!

When point is created it automatically goes to map. Test it:

>>> print(Map)
Map 1000x1000:
1. A @ 100, 100
2. B @ 200, 200
3. C @ 300, 200

We could add some group of points:

>>> Group1 = Orientation.group_of_points(Map, "Some", B, C)

And try to print Map now:

>>> print(Map)
Map 1000x1000:
1. A @ 100, 100
2. B @ 200, 200
3. C @ 300, 200
4. Some group [B @ 200, 200; C @ 300, 200]

If we want for points (or any other map object) to not add to Map, we should set quiet to True (*e.g.:* ``point(400, 300, Map, quiet=True)``).

Now it's time for some rects:

>>> Rect1 = Orientation.rect(100, 100, 100, 100, Map)
>>> print(Map)
1. A @ 100, 100
2. Some group [B @ 200, 200; C @ 300, 200]
3. B @ 200, 200
4. C @ 300, 200
5. Unknown rect 100X100 @ 100, 100

Rects support some interesting things:

>>> A in Rect1
True
>>> B in Rect1
True
>>> C in Rect1
False
>>> Group1 in Rect1
False
>>> Orientation.group_of_points(Map, "Some", A, B) in Rect1
True
>>> Rect1 in Rect1
True
>>> Orientation.rect(150, 100, 100, 100, Map) in Rect1
False

I think you got the point but in case you didn't:
    - If point is in inside rect **or** on edges of rect then ``point in rect`` is ``True``.
    - If ``point in rect`` is True for **all** points in group_of_points then ``group_of_points in rect`` is ``True``.
    - If **all** parts of rect1 are in rect2 then ``rect1 in rect2`` is ``True``.
    - In all examples if it isn't ``True`` it's ``False``.

Library for now also has ``line``, ``line-seg``, ``ray``, ``direction`` and ``circle`` classes but they aren't so important so I won't cover using them.

Important thing is ``ext_obj`` class. It's any Map object but with some additional properties:

>>> p1 = Orientation.ext_obj(point(10, 10, Map, "some", quiet=True), "weird", "very strange", type="non-normal")

Now you may ask why do you need all that? You maybe think: "*It would probably be better if I do my map exactly for my game, only map loading is problem.*"

Because of that I will now start explaining using *Tiled* map (*.tmx* extension).

We probably need to set the map:

>>> Map = Orientation.tiled_map("first_level")
<tiledtmxloader.tmxreader.TileSet object at 0x01C9B3D0>
SpriteLayer: Sprite Cache hits: 0

Now we could print map (I will show just beginning of output because it have 103 lines):

>>> print(Map)
Tiled map 2000x500:
1. object  rect 20X500 @ 0, 0
2. object  rect 1980X20 @ 20, 0
3. object  rect 1980X20 @ 20, 480

You may notice that print output looks like Map print output and all objects are converted to ``ext_obj``.

I think it's best to **not** work in python shell.

We should first create main pygame loop (It doesn't use Mind but we'll need it), something like this:

.. literalinclude:: pro_1-p.py

I asume that you understand everything in that code.

Next we should add Map initialization and Map blitting:

.. literalinclude:: pro_1-1.py
   :linenos:
   :emphasize-lines: 8,18

Line 8: We loaded map from file *first_level.tmx* ( *.tmx* extension automatically added by programm).

Line 18: Programm blits Map.

Now we have camera with center on point (0, 0) of the map (uper left corner).

But what if we want to have camera somewhere else? Then we should set map *position*:

.. literalinclude:: pro_1-2.py
   :linenos:
   :emphasize-lines: 10

Line 10: We set center position of camera to *200, 200*.

If you edge is ``True`` in ``Map.set_camera_pos`` (which is by default) then map won't be blitted outside the edges.

If we want to have map which will move when we press arrows we need to use *moving_map*:

.. literalinclude:: pro_1-3.py
   :linenos:
   :emphasize-lines: 8

Line 8: We changed Map class to ``moving_map``

For moving map we need ``Map.move(x, y)``:

.. literalinclude:: pro_1-4.py
   :linenos:
   :emphasize-lines: 16-24

Besides we added title in line 6, we seted that when pressing *UP* map *y* decreases for 10 and so on.

Now try to move map.

Left and right works but up doesn't.
That's because in begining Map center is in point (500, 500) and when you press key up it's in point (500, 490) but it looks same because in both situations map would be blitted out of Map but it automatically blits on edge.

We should use ``set_position()`` and ``get_camera_pos()`` methods for fixing that:

.. literalinclude:: pro_1-5.py
   :linenos:
   :emphasize-lines: 10, 27

Line 10: We define that center of map is center of map inside the edges.

Line 27: Like in line 9, but this line executes while game is running.

Now it's time for some object to appear. We'll define it as letter 'A':

.. literalinclude:: pro_1-6.py
   :linenos:
   :emphasize-lines: 11-18, 24, 26, 28, 30, 32, 37

Lines 11 and 12: Setting map edges (in further examples we won't use this feature).

Line 14: Reetting screen (because of edges).

Lines 16-18: Initialization of object.

Lines 27, 29, 31, 33: Instead of moving map we move object.

Line 36: Sets player pos as map center position.

Line 38: Blits player onto screen.

.. note::
   We don't need :py:class:`Mind.Orientation.moving_map` anymore and in further examples it will be replaced with :py:class:`Mind.Orientation.tiled_map`.

Now we'll load object from map. I assume that object both name and type are "player".

.. literalinclude:: pro_1-7.py
   :linenos:
   :emphasize-lines: 5-8, 16-18

Lines 5-8: We're defining subclass of :py:class:`Mind.Orientation.Subject` and we set picture to letter 'A'.

Line 16: We define Map decoding. Third dict (only non-empty dict) is object decoding, so we're saying that every object with type player (you can choose any type) is object of class player.

Line 18: We *clone* object with name player (you can choose any name). If you want to clone by type use ``p = Map.clone_obj("player", "type")``

.. note::
   We don't have to write ``p.blit()`` anymore because player is part of ``Map`` objects so when be blit ``Map`` we blit ``p``.

Map initialization has got some more advenced options but I'm not going to show them because they aren't necessary.

.. note::
   I might extend this tutorial (for Mind.Orientation), but feel free to extend this tutorial (and send me source) or create completely new tutorial.

Mind.Imagination
--------------------------------------------------------
Imagination is part of library for Main Menu.

.. note::
   Because this all classes need pygame initialization, it would be pointless to do this in shell.

I supose you have code similiar to this (and understand it):

.. literalinclude:: pro_2-p.py

Next step would be code like this:

.. literalinclude:: pro_2-1.py
   :emphasize-lines: 11-18,21,22,26
   :linenos:

Line 11: We create Main Menu which is on active place (but that place doesn't matter because it's only one) and has 150 pixels between each option (but it currently doesn't have options).

Lines 12-13: We get keyboard from Main Menu and then add ``(pygame.K_ESCAPE, "quit")`` to it. So basically if we press *esc* ``keyboard["quit"]`` would be ``True`` .

Lines 15-17: We add option to Main Menu which uses font from line 9, have text "Start", is red, it's Main Menu is one from line 11 and is option on which index is. And we also add two similar options with some different attributes.

Line 18: We finish our options defining. You don't have to know what this does but it must be on end of options defining.

Lines 21-22: If keyboard *quit* is on (so if we pressed esc) then game will stop running.

Line 26: Main Menu blits on screen.

When you run it and hit space/enter one option will disappear. If you press *ecs* game quits.

If we want options to become black when index come to option we could do this:

.. literalinclude:: pro_2-2.py
   :emphasize-lines: 15-17
   :linenos:

Basically when index come to option its color changes to *0, 0, 0* (black).

But when index is not on option it's still black, so we should define what happens when we go away from option.
To do this we need *anti_pos_do* attribute:

.. literalinclude:: pro_2-3.py
   :emphasize-lines: 15-17
   :linenos:

Now it's time to add Game object. It is object can change which menu will be blitted.

.. literalinclude:: pro_2-4.py
   :emphasize-lines: 10-12, 23, 25, 27, 31
   :linenos:

Line 10: Now we need that place multiple times.

Line 12: We initialize game object with default place to ``Places[0]``. We also use ``Places[0]`` for Main menu in line 14.

Line 23: We set Game`` as Main_menu game.

Lines 25 and 27: We use Game running instead of our.

Now we will add that game exits when we press quit:

.. literalinclude:: pro_2-5.py
   :emphasize-lines: 20
   :linenos:

We define on line 20 that when we press quit game quits. Note that it's not same as ``Game.kill()`` on line 27 because of way of execution (it's complicated, but just don't use ``Game.kill()`` in option or ``Imagination.Quit`` outside option). Also for this ability you need to have lines: 12, 23 and 25.

We will now add option menu. If we have two menues we should have places and second place should be off.

.. literalinclude:: pro_2-6.py
   :emphasize-lines: 10, 25-30
   :linenos:

Line 10: Now we need two places.

Line 25: We create Options Menu just like Main Menu, but this is on second place and have keyboard from Main Menu.

Lines 26-30: Just like in Main Menu, Back option have link to first place.

You might see that some settings in creating options are always same like type of option (``text option``), font and similar.

We can *define* that options:

.. literalinclude:: pro_2-7.py
   :emphasize-lines: 14, 15, 23-25, 32, 33
   :linenos:

Line 14: We defined what is same to all options.

Line 15: We set these options for Game.

Lines 23-25, 32, 33: Instead of making options and adding them in Main Menu and Options Menu, we now set them with ``set_from`` method and we don't need to repeat things defined in line 14

Now let's play a bit with positions:

.. literalinclude:: pro_2-8.py
   :emphasize-lines: 14, 17, 28
   :linenos:

Line 14: We added changing position (``Imagination.ch_pos((10, 0))``) in ``pos_do`` so when you go to option it moves 10% os screen right. When we go away from option it resets both colour and position so no need for new code.

Lines 17 and 28: We set off to -30 so options will be 30% of screen left than usual.

Menus, like options, have some settings same (offset, type...) so we can *declare* them:

.. literalinclude:: pro_2-9.py
   :emphasize-lines: 16-19, 28
   :linenos:

Lines 16 and 17 are same like lines 14 and 15 except 16 and 17 are for menus.

Lines 19 and 18: We get both menus from game now so we don't need ``.set_game`` method.

For now this turtorial ended, next version will probably have some new things.

Mind.Existence
--------------------------------------------------------------
Existence is part of library for things in gameplay.

As always at beginning:

>>> from Mind import Existence

Let me introduce you in group/object module:

>>> gr1 = Existence.group()
>>> gr1
Group
>>> ob1 = Existence.Object(gr1)
>>> ob2 = Existence.Object(gr1)
>>> gr1
Group [Object, Object]
>>> ob1
Object [Group]

Groups can also have groups and it's possible for object to be in multiple groups:

>>> ob3 = Existence.Object()
>>> gr2 = Existence.group(ob3, ob1, groups=[gr1])
>>> gr1
Group [Object, Object, Group]
>>> gr2
Group [Object, Object]

.. note:: Rest of tutorial is continued from Mind.Orientation tutorial

We need to import Existence and we need to use ``Existence.mov_type`` instead of *Subject*:

.. literalinclude:: pro_3-1.py
   :emphasize-lines: 1, 10
   :linenos:

Line 1: We now need to import Existence too.

Line 10: We define player as ``mov_type`` with picture letter *A* and Map not defined.

But player doesn't define camera position because it's normal object (like ``Orientation.map_obj``). We should add subject logic:

.. literalinclude:: pro_3-2.py
   :emphasize-lines: 10
   :linenos:

In line 10 we defined ``mov_type`` logic to be subject.

Now let me introduce you to gravity:

.. literalinclude:: pro_3-3.py
   :emphasize-lines: 10-19
   :linenos:

Line 10 and 11: We created class ``gravity`` with decorator ``logic_class``.

Line 13: When player object initialize it sets vertivcal force (``fy``) to 0.

Line 16: Every time player blits ``fy`` is bigger for 0.1.

Line 17: Every time player blits player goes down for ``fy``.

Line 19: We now use gravity with Subject as logic.

.. note::
   Althrought I will continue writting this tutorial, you may expand it or create completely new tutorial (your will probably be a way better) and send me link (*jakov.manjkas@gmail.com*).