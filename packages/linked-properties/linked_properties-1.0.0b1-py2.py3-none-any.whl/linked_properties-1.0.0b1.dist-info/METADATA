Metadata-Version: 2.0
Name: linked-properties
Version: 1.0.0b1
Summary: This library allows you to link properties, so if one is changed the others change accordingly.
Home-page: https://github.com/CNLambda/linked_properties/
Author: CNLambda
Author-email: dodo2998@gmail.com
License: UNLICENSE
Keywords: linking properties
Platform: UNKNOWN
Classifier: Development Status :: 4 - Beta
Classifier: Intended Audience :: Developers
Classifier: License :: Freely Distributable
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.5

Linked Properties
#################

This is a python library that allows you to link properties together, so
if one is changed the others change accordingly.

You can use this library everywhere, I don't care. Giving credit would
be nice, but is optional.

Installing
==========

.. code-block:: bash

    $ pip install linked_properties

Using
=====

The library consists of two important parts: ``WatchableProperty`` and
``LinkableProperty``.

A class named ``ComplexLinkedProperty`` or something like that may be
added in the future, it would combine both concepts; but it would need
additional work. I added the documentation anyways.

``WatchableProperty``
---------------------

As the docstring states:

::

    WatchableProperty is a class that is used to create a property that can be submitted to a LinkableProperty.

    It works exactly the same as "property", except for the name.

    If a linked property is reading from another one, than this object may be blocked for writing for the instance in question.
    To get around this, you may define an "at_blocked_set" function, that unlocks the linked property by setting it to None. It may return true or false, if it is true, the __set__ function is called another time.

    Note: the at_blocked_set function can invoke the __set__ function again only once per tried write access!

You *cannot* use normal properties to make LinkableProperties work.

Here's how you can use them (Spoiler Alert: It's (almost) exactly the same as
with the builtin properties):
* 1st option: Replace the builtin property (kind of). This *should generally not be used*, although it can be used if you are updating an old project to fit the requirements automatically.

.. code-block:: python

    import linked_properties
    property = linked_properties.WatchableProperty
    # ... (Your own code)

* 2nd option: Using them with function decorators. This *should* be the preferred way, but some (or just this one, i don't know) editors like PyCharm think you are working with the builtin properties. This may lead to warnings that shouldn't exist.

.. code-block:: python

    import linked_properties
    # ... (Your own code)

    class SomeName(object): # ... (Your own code)
        @linked_properties.WatchableProperty
        def x(self) -> int:
            return self._x

        @x.setter
        def x(self, value: int) -> None:
            self._x = int(value)

            # ... (Your own code)

    # ... (Your own code)

* 3rd option: Using them the ugly way.
  This is still better than the first one,
  and it's the only one to make PyCharm stop spawning warnings because of types all over the place.

.. code-block:: python

    import linked_properties
    # ... (Your own code)

    class SomeName(object): # ... (Your own code)
        # ... (Your own code)

        def _get_x(self) -> int:
            return self._x

        def _set_x(self, value: int) -> None:
            self._x = value

        x = linked_properties.WatchableProperty(_get_x, _set_x)

        # ... (Your own code)

    # ... (Your own code)


But be aware of this: Two things is different.

While ``@property_name.setter`` **returns a new instance** for a builtin property because they are **immutable**, a WatchableProperty **returns itself and changes accordingly** because it is **mutable**.

Just try to avoid situations where you need mutable or immutable descriptors, because this behaviour can change in future versions. (I can't even think of a situation where this would help)

And you **cannot** define a deleter, although that may change in the future as well.

``LinkableProperty``
--------------------

As the docstring states:

::

    The main functionality[.] [...]


You cannot define any getter, setter or deleter. The init function takes a ``WatchableProperty``.

The definition is simple, and the usage is as well:

If you have two LinkedProperties, you can set one to be the other (``obj1.l_x = obj2.l_x``). This results in following behaviour:

You can't set the associated ``WatchableProperty`` of the receiving ``LinkableProperty`` anymore (at least not by ``obj1.x = ...``), and if the associated ``WatchableProperty`` of the sending ``LinkableProperty`` gets changed, the setter of the other ``WatchableProperty`` gets called.

If you want to unlink them, set the receiving ``LinkableProperty`` to ``None``. (``obj1.l_x = None``)

**Be aware of this:** You should *only* use LinkedProperties if your property *makes sense to be able to get linked*. This excludes properties that count how often something was written to or read, and everything that *changes behaviour after writing the same value or reading twice*.

``LinkableTransmission``
------------------------

This is the object the getter of a ``LinkableProperty`` returns, to be able to connect with other LinkedProperties.

You don't have to care about this one, if you don't want to change how the library works.
I put this in anyway, because this will be expanded in the next version; allowing you to interact with it like you would interact with the underlying value.
(-> ``obj1.l_x = obj2.l_x * 2``)

If the ``ComplexLinkableProperty`` is implemented, using ``transmission.value`` may be important to let it be used by other libraries.
Using this technique is also important if you want to set the new value only once, and don't want those two properties to be linked.

``ComplexLinkableProperty``
---------------------------

***This is not implemented yet.***

This LinkableProperty will be a ``LinkableProperty``, with a getter and setter that you define,
and you can assign values to this properties, and not just transmissions.
If you want to be able to set the property to a transmission, you have to use the current way of dealing with LinkedProperties.

This returns a LinkableTransmission if you are receiving, with a ``transmission.value`` gathered by the getter. If you are trying to set the attribute, one of two things will happen:

* If the value is a ``LinkableTransmission`` or a subclass: The property gets linked by the transmission.

* If it isn't: Run the setter with the new value.

The setter will also run when the value of the linked property changes, or if they are linked.

Example
-------

I personally can learn better from examples. So here is one:

.. code-block:: python

    import linked_properties

    class Widget(object):
        def __init__(self, width: int, height: int) -> None:
            self._width = 0  # type: int
            self._height = 0  # type: int

            self.width = width
            self.height = height

        @linked_property.WatchableProperty
        def width(self) -> int:
            return self._width

        @width.setter
        def width(self, new_value: int) -> None:
            assert isinstance(new_value, int)
            self._width = new_value

        l_width = linked_properties.LinkableProperty(width)

        # ...  (height; see width)

Or after the ``ComplexLinkableProperty`` arrived:

.. code-block:: python

    import linked_properties

    class Widget(object):
        def __init__(self, width: int, height: int) - None:
            self._width = 0  # type: int
            self._height = 0  # type: int

            self.width = width
            self.height = height

        @linked_property.ComplexLinkableProperty
        def width(self) -> int:
            return self._width

        @width.setter
        def width(self, new_value: int) -> None:
            assert isinstance(new_value, int)
            self._width = new_value

Contributing
============

If you want to contribute, just email me: dodo2998@gmail.com

